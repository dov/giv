/* Generated by GOB (v2.0.12) on Sat Oct  4 21:54:16 2008
   (do not edit directly) */

/* End world hunger, donate to the World Food Programme, http://www.wfp.org */

#define GOB_VERSION_MAJOR 2
#define GOB_VERSION_MINOR 0
#define GOB_VERSION_PATCHLEVEL 12

#define selfp (self->_priv)

#include <string.h> /* memset() */

#include "gtk-image-viewer.h"

#include "gtk-image-viewer-private.h"

#ifdef G_LIKELY
#define ___GOB_LIKELY(expr) G_LIKELY(expr)
#define ___GOB_UNLIKELY(expr) G_UNLIKELY(expr)
#else /* ! G_LIKELY */
#define ___GOB_LIKELY(expr) (expr)
#define ___GOB_UNLIKELY(expr) (expr)
#endif /* G_LIKELY */

#line 14 "src/gtk-image-viewer.gob"

#define DBG(a) 
#define DBG2(a) 

static gint view_changed(GtkImageViewer *image_widget,
			 int do_force,
			 double scale_x,
			 double scale_y,
			 double x0,
			 double y0);

static gint zoom_reset(GtkImageViewer *self);
static gint zoom_fit(GtkImageViewer *self);
static gint zoom_in(GtkImageViewer *self, int x, int y, double factor);
static gint zoom_out(GtkImageViewer *self, int x, int y, double factor);
static gint zoom_translate(GtkImageViewer *self, int dx, int dy);
static gboolean update_adjustments(GtkImageViewer *image_viewer);
static void vadjustment_value_changed (GtkAdjustment *vadjustment,
                                       gpointer       data);
static void hadjustment_value_changed (GtkAdjustment *hadjustment,
                                       gpointer       data);


#line 51 "gtk-image-viewer.cc"
/* self casting macros */
#define SELF(x) GTK_IMAGE_VIEWER(x)
#define SELF_CONST(x) GTK_IMAGE_VIEWER_CONST(x)
#define IS_SELF(x) GTK_IS_IMAGE_VIEWER(x)
#define TYPE_SELF GTK_TYPE_IMAGE_VIEWER
#define SELF_CLASS(x) GTK_IMAGE_VIEWER_CLASS(x)

#define SELF_GET_CLASS(x) GTK_IMAGE_VIEWER_GET_CLASS(x)

/* self typedefs */
typedef GtkImageViewer Self;
typedef GtkImageViewerClass SelfClass;

/* here are local prototypes */
static void gtk_image_viewer_init (GtkImageViewer * self) G_GNUC_UNUSED;
static void gtk_image_viewer_class_init (GtkImageViewerClass * self) G_GNUC_UNUSED;
static void ___5_gtk_image_viewer_realize (GtkWidget * self) G_GNUC_UNUSED;
static void ___6_gtk_image_viewer_size_request (GtkWidget * widget, GtkRequisition * requisition) G_GNUC_UNUSED;
static void ___7_gtk_image_viewer_size_allocate (GtkWidget * widget, GtkAllocation * allocation) G_GNUC_UNUSED;
static gint ___8_gtk_image_viewer_expose_event (GtkWidget * widget, GdkEventExpose * event) G_GNUC_UNUSED;
static gint ___9_gtk_image_viewer_enter_notify_event (GtkWidget * widget, GdkEventCrossing * event) G_GNUC_UNUSED;
static gint ___a_gtk_image_viewer_leave_notify_event (GtkWidget * widget, GdkEventCrossing * event) G_GNUC_UNUSED;
static gint ___b_gtk_image_viewer_key_press_event (GtkWidget * widget, GdkEventKey * event) G_GNUC_UNUSED;
static gint ___c_gtk_image_viewer_button_press_event (GtkWidget * widget, GdkEventButton * event) G_GNUC_UNUSED;
static gint ___d_gtk_image_viewer_button_release_event (GtkWidget * widget, GdkEventButton * event) G_GNUC_UNUSED;
static gint ___e_gtk_image_viewer_motion_notify_event (GtkWidget * widget, GdkEventMotion * event) G_GNUC_UNUSED;
static gint ___f_gtk_image_viewer_scroll_event (GtkWidget * widget, GdkEventScroll * event) G_GNUC_UNUSED;
static void ___real_gtk_image_viewer_set_scroll_adjustments (GtkImageViewer * self, GtkAdjustment * hadjustment, GtkAdjustment * vadjustment);

/*
 * Signal connection wrapper macro shortcuts
 */
#define self_connect__set_scroll_adjustments(object,func,data)	gtk_image_viewer_connect__set_scroll_adjustments((object),(func),(data))
#define self_connect_after__set_scroll_adjustments(object,func,data)	gtk_image_viewer_connect_after__set_scroll_adjustments((object),(func),(data))
#define self_connect_data__set_scroll_adjustments(object,func,data,destroy_data,flags)	gtk_image_viewer_connect_data__set_scroll_adjustments((object),(func),(data),(destroy_data),(flags))
#define self_connect__image_annotate(object,func,data)	gtk_image_viewer_connect__image_annotate((object),(func),(data))
#define self_connect_after__image_annotate(object,func,data)	gtk_image_viewer_connect_after__image_annotate((object),(func),(data))
#define self_connect_data__image_annotate(object,func,data,destroy_data,flags)	gtk_image_viewer_connect_data__image_annotate((object),(func),(data),(destroy_data),(flags))
#define self_connect__flip_changed(object,func,data)	gtk_image_viewer_connect__flip_changed((object),(func),(data))
#define self_connect_after__flip_changed(object,func,data)	gtk_image_viewer_connect_after__flip_changed((object),(func),(data))
#define self_connect_data__flip_changed(object,func,data,destroy_data,flags)	gtk_image_viewer_connect_data__flip_changed((object),(func),(data),(destroy_data),(flags))

typedef void  (*___Sig1) (GtkImageViewer *, GObject *, GObject *, gpointer);

static void
___marshal_Sig1 (GClosure *closure,
	GValue *return_value,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint,
	gpointer marshal_data)
{
	register ___Sig1 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 3);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig1) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GtkImageViewer *)data1,
		(GObject *) g_value_get_object (param_values + 1),
		(GObject *) g_value_get_object (param_values + 2),
		data2);

	return_value = NULL;
	invocation_hint = NULL;
}


typedef void  (*___Sig2) (GtkImageViewer *, gpointer , gint , gint , gdouble , gdouble , gpointer);

static void
___marshal_Sig2 (GClosure *closure,
	GValue *return_value,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint,
	gpointer marshal_data)
{
	register ___Sig2 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 6);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig2) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GtkImageViewer *)data1,
		(gpointer ) g_value_get_pointer (param_values + 1),
		(gint ) g_value_get_int (param_values + 2),
		(gint ) g_value_get_int (param_values + 3),
		(gdouble ) g_value_get_double (param_values + 4),
		(gdouble ) g_value_get_double (param_values + 5),
		data2);

	return_value = NULL;
	invocation_hint = NULL;
}


typedef void  (*___Sig3) (GtkImageViewer *, gint , gint , gpointer);

static void
___marshal_Sig3 (GClosure *closure,
	GValue *return_value,
	guint n_param_values,
	const GValue *param_values,
	gpointer invocation_hint,
	gpointer marshal_data)
{
	register ___Sig3 callback;
	register GCClosure *cc = (GCClosure*) closure;
	register gpointer data1, data2;

	g_return_if_fail (n_param_values == 3);

	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = g_value_peek_pointer (param_values + 0);
	} else {
		data1 = g_value_peek_pointer (param_values + 0);
		data2 = closure->data;
	}

	callback = (___Sig3) (marshal_data != NULL ? marshal_data : cc->callback);

	callback ((GtkImageViewer *)data1,
		(gint ) g_value_get_int (param_values + 1),
		(gint ) g_value_get_int (param_values + 2),
		data2);

	return_value = NULL;
	invocation_hint = NULL;
}


enum {
	SET_SCROLL_ADJUSTMENTS_SIGNAL,
	IMAGE_ANNOTATE_SIGNAL,
	FLIP_CHANGED_SIGNAL,
	LAST_SIGNAL
};

static guint object_signals[LAST_SIGNAL] = {0};

/* pointer to the class of our parent */
static GtkWidgetClass *parent_class = NULL;

/* Short form macros */
#define self_new gtk_image_viewer_new
#define self_new_from_file gtk_image_viewer_new_from_file
#define self_expose_area gtk_image_viewer_expose_area
#define self_set_freeze gtk_image_viewer_set_freeze
#define self_redraw gtk_image_viewer_redraw
#define self_zoom_around_fixed_point gtk_image_viewer_zoom_around_fixed_point
#define self_zoom_to_box gtk_image_viewer_zoom_to_box
#define self_set_hadjustment gtk_image_viewer_set_hadjustment
#define self_set_vadjustment gtk_image_viewer_set_vadjustment
#define self_set_image gtk_image_viewer_set_image
#define self_get_image gtk_image_viewer_get_image
#define self_set_scroll_adjustments gtk_image_viewer_set_scroll_adjustments
#define self_image_annotate gtk_image_viewer_image_annotate
#define self_flip_changed gtk_image_viewer_flip_changed
#define self_get_image_width gtk_image_viewer_get_image_width
#define self_get_image_height gtk_image_viewer_get_image_height
#define self_canv_coord_to_img_coord gtk_image_viewer_canv_coord_to_img_coord
#define self_img_coord_to_canv_coord gtk_image_viewer_img_coord_to_canv_coord
#define self_set_zoom_range gtk_image_viewer_set_zoom_range
#define self_get_scale_and_shift gtk_image_viewer_get_scale_and_shift
#define self_set_transfer_map gtk_image_viewer_set_transfer_map
#define self_set_fill_on_resize gtk_image_viewer_set_fill_on_resize
#define self_one_shot_block_fill_on_resize gtk_image_viewer_one_shot_block_fill_on_resize
#define self_get_fill_on_resize gtk_image_viewer_get_fill_on_resize
#define self_set_scroll_region gtk_image_viewer_set_scroll_region
#define self_set_flip gtk_image_viewer_set_flip
#define self_zoom_reset gtk_image_viewer_zoom_reset
#define self_zoom_fit gtk_image_viewer_zoom_fit
GType
gtk_image_viewer_get_type (void)
{
	static GType type = 0;

	if ___GOB_UNLIKELY(type == 0) {
		static const GTypeInfo info = {
			sizeof (GtkImageViewerClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) gtk_image_viewer_class_init,
			(GClassFinalizeFunc) NULL,
			NULL /* class_data */,
			sizeof (GtkImageViewer),
			0 /* n_preallocs */,
			(GInstanceInitFunc) gtk_image_viewer_init,
			NULL
		};

		type = g_type_register_static (GTK_TYPE_WIDGET, "GtkImageViewer", &info, (GTypeFlags)0);
	}

	return type;
}

/* a macro for creating a new object of our type */
#define GET_NEW ((GtkImageViewer *)g_object_new(gtk_image_viewer_get_type(), NULL))

/* a function for creating a new object of our type */
#include <stdarg.h>
static GtkImageViewer * GET_NEW_VARG (const char *first, ...) G_GNUC_UNUSED;
static GtkImageViewer *
GET_NEW_VARG (const char *first, ...)
{
	GtkImageViewer *ret;
	va_list ap;
	va_start (ap, first);
	ret = (GtkImageViewer *)g_object_new_valist (gtk_image_viewer_get_type (), first, ap);
	va_end (ap);
	return ret;
}


static void
___finalize(GObject *obj_self)
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::finalize"
	GtkImageViewer *self G_GNUC_UNUSED = GTK_IMAGE_VIEWER (obj_self);
	gpointer priv G_GNUC_UNUSED = self->_priv;
	if(G_OBJECT_CLASS(parent_class)->finalize) \
		(* G_OBJECT_CLASS(parent_class)->finalize)(obj_self);
}
#undef __GOB_FUNCTION__

#line 84 "src/gtk-image-viewer.gob"
static void 
gtk_image_viewer_init (GtkImageViewer * self)
#line 303 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::init"
	self->_priv = G_TYPE_INSTANCE_GET_PRIVATE(self,GTK_TYPE_IMAGE_VIEWER,GtkImageViewerPrivate);
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->image = NULL;
#line 309 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->current_scale_x = 1;
#line 312 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->current_scale_y = 1;
#line 315 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->do_flip_vertical = false;
#line 318 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->do_flip_horizontal = false;
#line 321 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->do_use_transfer_map = false;
#line 324 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->do_fill_on_resize = true;
#line 327 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->one_shot_block_fill_on_resize = false;
#line 330 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->interp_type = GDK_INTERP_NEAREST;
#line 333 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->scroll_width = -1;
#line 336 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->scroll_height = -1;
#line 339 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->hadjustment = NULL;
#line 342 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->vadjustment = NULL;
#line 345 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->is_mouse_button2_pressed = FALSE;
#line 348 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->cache_area = NULL;
#line 351 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->cache_scale_x = -1;
#line 354 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->cache_scale_y = -1;
#line 357 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->cache_current_x0 = -1;
#line 360 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->cache_current_y0 = -1;
#line 363 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->cache_width = -1;
#line 366 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->cache_height = -1;
#line 369 "gtk-image-viewer.cc"
#line 14 "src/gtk-image-viewer.gob"
	self->_priv->frozen = FALSE;
#line 372 "gtk-image-viewer.cc"
 {
#line 85 "src/gtk-image-viewer.gob"

    GTK_WIDGET_SET_FLAGS (self, GTK_CAN_FOCUS);
    selfp->interp_type = GDK_INTERP_NEAREST;
    selfp->do_linear_zoom_steps = FALSE;
    selfp->do_use_transfer_map = FALSE;
    selfp->do_flip_vertical = FALSE;
    selfp->do_flip_horizontal = FALSE;
    selfp->current_scale_x = 1.0;
    selfp->current_scale_y = 1.0;
    selfp->current_x0 = 0;
    selfp->current_y0 = 0;
    selfp->min_zoom = 1.0/8;
    selfp->max_zoom = 128;
    selfp->scroll_width = -1;
    selfp->scroll_height = -1;
    selfp->gc = NULL;
    selfp->hadjustment = 0;
    selfp->vadjustment = 0;
    selfp->frozen = FALSE;
  
#line 395 "gtk-image-viewer.cc"
 }
}
#undef __GOB_FUNCTION__
#line 106 "src/gtk-image-viewer.gob"
static void 
gtk_image_viewer_class_init (GtkImageViewerClass * self)
#line 402 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::class_init"
	GObjectClass *g_object_class G_GNUC_UNUSED = (GObjectClass*) self;
	GtkWidgetClass *gtk_widget_class = (GtkWidgetClass *)self;

	g_type_class_add_private(self,sizeof(GtkImageViewerPrivate));

	parent_class = (GtkWidgetClass *)g_type_class_ref (GTK_TYPE_WIDGET);

	object_signals[SET_SCROLL_ADJUSTMENTS_SIGNAL] =
		g_signal_new ("set_scroll_adjustments",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GtkImageViewerClass, set_scroll_adjustments),
			NULL, NULL,
			___marshal_Sig1,
			G_TYPE_NONE, 2,
			G_TYPE_ADJUSTMENT,
			G_TYPE_ADJUSTMENT);
	if ___GOB_UNLIKELY(sizeof(GtkAdjustment * ) != sizeof(GObject *) || sizeof(GtkAdjustment * ) != sizeof(GObject *) || parent_class == NULL /* avoid warning */) {
		g_error("src/gtk-image-viewer.gob line 1371: Type mismatch of \"set_scroll_adjustments\" signal signature");
	}
	object_signals[IMAGE_ANNOTATE_SIGNAL] =
		g_signal_new ("image_annotate",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GtkImageViewerClass, image_annotate),
			NULL, NULL,
			___marshal_Sig2,
			G_TYPE_NONE, 5,
			G_TYPE_POINTER,
			G_TYPE_INT,
			G_TYPE_INT,
			G_TYPE_DOUBLE,
			G_TYPE_DOUBLE);
	if ___GOB_UNLIKELY(sizeof(GdkPixbuf * ) != sizeof(gpointer ) || sizeof(gint ) != sizeof(gint ) || sizeof(gint ) != sizeof(gint ) || sizeof(gdouble ) != sizeof(gdouble ) || sizeof(gdouble ) != sizeof(gdouble ) || parent_class == NULL /* avoid warning */) {
		g_error("src/gtk-image-viewer.gob line 1383: Type mismatch of \"image_annotate\" signal signature");
	}
	object_signals[FLIP_CHANGED_SIGNAL] =
		g_signal_new ("flip_changed",
			G_TYPE_FROM_CLASS (g_object_class),
			(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),
			G_STRUCT_OFFSET (GtkImageViewerClass, flip_changed),
			NULL, NULL,
			___marshal_Sig3,
			G_TYPE_NONE, 2,
			G_TYPE_INT,
			G_TYPE_INT);
	if ___GOB_UNLIKELY(sizeof(gboolean ) != sizeof(gint ) || sizeof(gboolean ) != sizeof(gint ) || parent_class == NULL /* avoid warning */) {
		g_error("src/gtk-image-viewer.gob line 1390: Type mismatch of \"flip_changed\" signal signature");
	}

#line 131 "src/gtk-image-viewer.gob"
	gtk_widget_class->realize = ___5_gtk_image_viewer_realize;
#line 177 "src/gtk-image-viewer.gob"
	gtk_widget_class->size_request = ___6_gtk_image_viewer_size_request;
#line 196 "src/gtk-image-viewer.gob"
	gtk_widget_class->size_allocate = ___7_gtk_image_viewer_size_allocate;
#line 325 "src/gtk-image-viewer.gob"
	gtk_widget_class->expose_event = ___8_gtk_image_viewer_expose_event;
#line 338 "src/gtk-image-viewer.gob"
	gtk_widget_class->enter_notify_event = ___9_gtk_image_viewer_enter_notify_event;
#line 350 "src/gtk-image-viewer.gob"
	gtk_widget_class->leave_notify_event = ___a_gtk_image_viewer_leave_notify_event;
#line 362 "src/gtk-image-viewer.gob"
	gtk_widget_class->key_press_event = ___b_gtk_image_viewer_key_press_event;
#line 411 "src/gtk-image-viewer.gob"
	gtk_widget_class->button_press_event = ___c_gtk_image_viewer_button_press_event;
#line 438 "src/gtk-image-viewer.gob"
	gtk_widget_class->button_release_event = ___d_gtk_image_viewer_button_release_event;
#line 483 "src/gtk-image-viewer.gob"
	gtk_widget_class->motion_notify_event = ___e_gtk_image_viewer_motion_notify_event;
#line 530 "src/gtk-image-viewer.gob"
	gtk_widget_class->scroll_event = ___f_gtk_image_viewer_scroll_event;
#line 1371 "src/gtk-image-viewer.gob"
	self->set_scroll_adjustments = ___real_gtk_image_viewer_set_scroll_adjustments;
#line 479 "gtk-image-viewer.cc"
	self->image_annotate = NULL;
	self->flip_changed = NULL;
	g_object_class->finalize = ___finalize;
 {
#line 106 "src/gtk-image-viewer.gob"

    // The following statement does the magic of connecting the scrolled_window
    // packing to the scrolling of the image viewer.
    ((GtkWidgetClass*)self)->set_scroll_adjustments_signal = object_signals[SET_SCROLL_ADJUSTMENTS_SIGNAL];
  
#line 490 "gtk-image-viewer.cc"
 }
}
#undef __GOB_FUNCTION__



#line 112 "src/gtk-image-viewer.gob"
GtkWidget * 
gtk_image_viewer_new (GdkPixbuf * pixbuf)
#line 500 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::new"
{
#line 114 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self = GTK_IMAGE_VIEWER(GET_NEW);

    gtk_image_viewer_set_image(self, pixbuf);
    
    return GTK_WIDGET(self);
  }}
#line 512 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 122 "src/gtk-image-viewer.gob"
GtkWidget * 
gtk_image_viewer_new_from_file (const gchar * filename)
#line 518 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::new_from_file"
{
#line 124 "src/gtk-image-viewer.gob"
	
    GError *error = NULL;
    GdkPixbuf *pb = gdk_pixbuf_new_from_file(filename, &error);

    return gtk_image_viewer_new(pb);
  }}
#line 529 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 131 "src/gtk-image-viewer.gob"
static void 
___5_gtk_image_viewer_realize (GtkWidget * self)
#line 535 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___self) \
	{ if(GTK_WIDGET_CLASS(parent_class)->realize) \
		(* GTK_WIDGET_CLASS(parent_class)->realize)(___self); }
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::realize"
#line 131 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 131 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_WIDGET (self));
#line 545 "gtk-image-viewer.cc"
{
#line 134 "src/gtk-image-viewer.gob"
	
    GtkWidget *widget = GTK_WIDGET(self);
    GdkWindowAttr attributes;
    gint attributes_mask;
    
    GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED);
      
    attributes.x = widget->allocation.x;
    attributes.y = widget->allocation.y;
    attributes.width = widget->allocation.width;
    attributes.height = widget->allocation.height;
    attributes.wclass = GDK_INPUT_OUTPUT;
    attributes.window_type = GDK_WINDOW_CHILD;
    attributes.event_mask = gtk_widget_get_events (widget) | 
      GDK_EXPOSURE_MASK |
      GDK_BUTTON_PRESS_MASK | 
      GDK_BUTTON_RELEASE_MASK |
      GDK_POINTER_MOTION_MASK |
      GDK_POINTER_MOTION_HINT_MASK | 
      GDK_KEY_PRESS_MASK |
      GDK_LEAVE_NOTIFY_MASK |
      GDK_ENTER_NOTIFY_MASK;
    attributes.visual = gtk_widget_get_visual (widget);
    attributes.colormap = gtk_widget_get_colormap (widget);
      
    attributes_mask = GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP;
    widget->window = gdk_window_new (widget->parent->window, &attributes, attributes_mask);
      
    widget->style = gtk_style_attach (widget->style, widget->window);
      
    gdk_window_set_user_data (widget->window, widget);
      
    // Force background to be white. This is uggly and should be fixed!
    {
      GdkColor color;
      gdk_color_parse("white", &color);
      gtk_widget_modify_bg(self, GTK_STATE_NORMAL, &color);
      gtk_widget_modify_bg(self, GTK_STATE_ACTIVE, &color);
    }

    //    gtk_style_set_background (widget->style, widget->window, GTK_STATE_ACTIVE);
  }}
#line 590 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 177 "src/gtk-image-viewer.gob"
static void 
___6_gtk_image_viewer_size_request (GtkWidget * widget, GtkRequisition * requisition)
#line 597 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___requisition) \
	{ if(GTK_WIDGET_CLASS(parent_class)->size_request) \
		(* GTK_WIDGET_CLASS(parent_class)->size_request)(___widget,___requisition); }
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::size_request"
{
#line 181 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self = GTK_IMAGE_VIEWER (widget);

    if (selfp->image) 
      {
        requisition->width = gdk_pixbuf_get_width(selfp->image);
        requisition->height = gdk_pixbuf_get_height(selfp->image);
      }
    else
      {
        requisition->width = 256;
        requisition->height = 256;
      }
  }}
#line 619 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 196 "src/gtk-image-viewer.gob"
static void 
___7_gtk_image_viewer_size_allocate (GtkWidget * widget, GtkAllocation * allocation)
#line 626 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___allocation) \
	{ if(GTK_WIDGET_CLASS(parent_class)->size_allocate) \
		(* GTK_WIDGET_CLASS(parent_class)->size_allocate)(___widget,___allocation); }
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::size_allocate"
{
#line 200 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self;
    int old_cnv_w, old_cnv_h;
  
    widget->allocation = *allocation;
    self = GTK_IMAGE_VIEWER (widget);
  
    if (GTK_WIDGET_REALIZED (widget)) {
        gdk_window_move_resize (widget->window,
                                allocation->x, allocation->y,
                                allocation->width, allocation->height);
        
        
    }
    
    old_cnv_w = selfp->canvas_width;
    old_cnv_h = selfp->canvas_height;

    selfp->canvas_width = widget->allocation.width;
    selfp->canvas_height = widget->allocation.height;
    if (GTK_IS_SCROLLED_WINDOW(GTK_WIDGET(self)->parent)) {
      GtkPolicyType hscrollbar_policy, vscrollbar_policy;
      gtk_scrolled_window_get_policy(GTK_SCROLLED_WINDOW(GTK_WIDGET(self)->parent),
                                     &hscrollbar_policy,
                                     &vscrollbar_policy);
#if 0
        printf("Replacing with parent size (%d,%d)->(%d,%d)...\n",
               selfp->canvas_width,
               selfp->canvas_height,
               GTK_WIDGET(self)->parent->allocation.width,
               GTK_WIDGET(self)->parent->allocation.height
               );
#endif
        if (hscrollbar_policy != GTK_POLICY_ALWAYS)
          selfp->canvas_width = GTK_WIDGET(self)->parent->allocation.width;
        
        if (vscrollbar_policy != GTK_POLICY_ALWAYS)
          selfp->canvas_height = GTK_WIDGET(self)->parent->allocation.height;
    }

    // If we were called because the scrollbar automatically appeared
    // then the scrolled_window size hasn't changed, and we don't shouldn't
    // do anything.
    if (old_cnv_w == selfp->canvas_width
        && old_cnv_h == selfp->canvas_height)
        return;

    double scale_factor = 1.0;

    if (!selfp->one_shot_block_fill_on_resize
        && selfp->do_fill_on_resize) {
        double sw = selfp->scroll_width;
        double sh = selfp->scroll_height; 
        double cw = selfp->canvas_width;
        double ch = selfp->canvas_height;
        double margin = 0;       // Add a 20 pixel margin if we are not using an image...

        if (sw < 0)
            sw = cw;
        if (sh < 0)
            sh = ch;
        
        // This should be made more sophisticated.
        if (!selfp->image) {
            cw-= 20;
            ch-= 20;
        }

        if (old_cnv_w == 0)
          scale_factor = 1;
        else
          scale_factor = 1.0*cw/old_cnv_w;
        if (scale_factor * selfp->current_scale_x * sw < cw)
            scale_factor = cw / sw / selfp->current_scale_x;

        double scale_factor_y = 1;
        if (old_cnv_h > 0)
           scale_factor_y = 1.0*ch/old_cnv_h;
        if (scale_factor_y * selfp->current_scale_y * sh < ch)
            scale_factor_y = ch/sh/selfp->current_scale_y;
        if (scale_factor_y < scale_factor)
            scale_factor = scale_factor_y;
    }
    selfp->one_shot_block_fill_on_resize = false;

    selfp->current_scale_x *= scale_factor;
    selfp->current_scale_y *= scale_factor;
    selfp->current_x0 *= scale_factor;
    selfp->current_y0 *= scale_factor;
  
    /* Update current_x0 and current_y0 to center data if the
     * new size is wider than scale * image size.
     */
    {
        double scale_x = selfp->current_scale_x;
        double scale_y = selfp->current_scale_y;
        double img_w = selfp->scroll_width*scale_x;
        double img_h = selfp->scroll_height*scale_y;
        int cnv_w = selfp->canvas_width;
        int cnv_h = selfp->canvas_height;
  
        DBG(fprintf(stderr,"Resize: x0 y0 img_w img_h cnv_w cnv_h = %d %d %f %f %d %d\n",
                    selfp->current_x0,selfp->current_y0,img_w,img_h,cnv_w,cnv_h));
  
        if (cnv_w > img_w)
          selfp->current_x0 = -(cnv_w-img_w)/2+selfp->scroll_min_x*scale_x;
        else if (old_cnv_w > img_w)
          selfp->current_x0 = selfp->scroll_min_x*scale_x;
        else if (img_w - selfp->current_x0 < cnv_w)
          {
            DBG(fprintf(stderr, "Resize case 3X\n"));
            selfp->current_x0 = img_w-cnv_w+selfp->scroll_min_x*scale_x;
          }
        if (cnv_h > img_h)
          selfp->current_y0 = -(cnv_h-img_h)/2+selfp->scroll_min_y*scale_y;
        else if (old_cnv_h > img_h)
          selfp->current_y0 = selfp->scroll_min_y*scale_y;
        else if (img_h - selfp->current_y0 < cnv_h)
          {
            DBG(fprintf(stderr, "Resize case 3Y\n"));
            selfp->current_y0 = img_h-cnv_h+selfp->scroll_min_y*scale_y;
          }
      }
  }}
#line 758 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 325 "src/gtk-image-viewer.gob"
static gint 
___8_gtk_image_viewer_expose_event (GtkWidget * widget, GdkEventExpose * event)
#line 765 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->expose_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->expose_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::expose_event"
{
#line 329 "src/gtk-image-viewer.gob"
	
    //    printf("expose_event\n");
    gtk_image_viewer_expose_area(GTK_IMAGE_VIEWER(widget),
                                 event->area.x, event->area.y,
                                 event->area.width, event->area.height);
    
    return FALSE;
  }}
#line 782 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 338 "src/gtk-image-viewer.gob"
static gint 
___9_gtk_image_viewer_enter_notify_event (GtkWidget * widget, GdkEventCrossing * event)
#line 789 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->enter_notify_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->enter_notify_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::enter_notify_event"
{
#line 342 "src/gtk-image-viewer.gob"
	
    // printf("Enter notify\n");
    if (!GTK_WIDGET_HAS_FOCUS (widget))
      gtk_widget_grab_focus (widget);
    
    return TRUE;
  }}
#line 805 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 350 "src/gtk-image-viewer.gob"
static gint 
___a_gtk_image_viewer_leave_notify_event (GtkWidget * widget, GdkEventCrossing * event)
#line 812 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->leave_notify_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->leave_notify_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::leave_notify_event"
{
#line 354 "src/gtk-image-viewer.gob"
	
    // printf("Leave notify\n");
    if (!GTK_WIDGET_HAS_FOCUS (widget))
      gtk_widget_grab_focus (widget);
    
    return TRUE;
  }}
#line 828 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 362 "src/gtk-image-viewer.gob"
static gint 
___b_gtk_image_viewer_key_press_event (GtkWidget * widget, GdkEventKey * event)
#line 835 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->key_press_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->key_press_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::key_press_event"
{
#line 366 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self = GTK_IMAGE_VIEWER(widget);
    int ret = TRUE;
    gint k;

    k = event->keyval;

    switch (k) {
    case '=':
    case '+':
        zoom_in(self, -1, -1, 1.1);
        break;
    case '>':
        zoom_in(self, -1, -1, 2);
        break;
    case '<':
        zoom_out(self, 0, 0, 2);
        break;
    case '-':
        zoom_out(self, 0, 0, 1.1);
        break;
    case '1':
    case 'n':
        zoom_reset(self);
        break;
    case 'f':
        gtk_image_viewer_zoom_fit(self);
        break;
    case 'v':
        gtk_image_viewer_set_flip(self,
                                  selfp->do_flip_horizontal,
                                  !selfp->do_flip_vertical);
        break;
    case 'h':
        gtk_image_viewer_set_flip(self,
                                  !selfp->do_flip_horizontal,
                                  selfp->do_flip_vertical);
        break;
    default:
        ret = FALSE;
        break;
    }
    return ret;
  }}
#line 888 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 411 "src/gtk-image-viewer.gob"
static gint 
___c_gtk_image_viewer_button_press_event (GtkWidget * widget, GdkEventButton * event)
#line 895 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->button_press_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->button_press_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::button_press_event"
{
#line 415 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self = GTK_IMAGE_VIEWER(widget);
    int button = event->button;
    double x = event->x;
    double y = event->y;
  
    if (button == 1)
        zoom_in(self, (int)x, (int)y, 2);
    else if (button == 2)
      {
        gtk_grab_add (GTK_WIDGET(self));
        selfp->is_mouse_button2_pressed = TRUE;
        selfp->last_pan_anchor_x = x;
        selfp->last_pan_anchor_y = y;
      }
    else if (button == 3)
        zoom_out(self, (int)x, (int)y, 2);
    
    selfp->button = event->button;
    
    return FALSE;
  }}
#line 926 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 438 "src/gtk-image-viewer.gob"
static gint 
___d_gtk_image_viewer_button_release_event (GtkWidget * widget, GdkEventButton * event)
#line 933 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->button_release_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->button_release_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::button_release_event"
{
#line 442 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self;
    gdouble x = event->x;
    gdouble y = event->y;
  
    g_return_val_if_fail (widget != NULL, FALSE);
    g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (widget), FALSE);
    g_return_val_if_fail (event != NULL, FALSE);
  
    self = GTK_IMAGE_VIEWER (widget);
  
    if (selfp->button == (int)event->button)
      {
        if (selfp->is_mouse_button2_pressed) {
  	selfp->is_mouse_button2_pressed = FALSE;
  	if (selfp->last_pan_anchor_x>0 && selfp->last_pan_anchor_y > 0)
  	    zoom_translate(self,
                           (int)(selfp->last_pan_anchor_x-x),
  			   (int)(selfp->last_pan_anchor_y-y));
  	gtk_grab_remove (GTK_WIDGET(self));
  
  	/* Emit an additional view changed signal at the end of the scrolling
  	   in order to support redrawing only when the panning is done.
  	*/
#if 0
  	gtk_signal_emit(GTK_OBJECT(image_viewer), gtk_image_viewer_signals[VIEW_CHANGED]);
#endif

        }
      }
  
    return FALSE;
  }}
#line 975 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 483 "src/gtk-image-viewer.gob"
static gint 
___e_gtk_image_viewer_motion_notify_event (GtkWidget * widget, GdkEventMotion * event)
#line 982 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->motion_notify_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->motion_notify_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::motion_notify_event"
{
#line 487 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self;
    GdkModifierType state;
    gint x, y;
  
    g_return_val_if_fail (widget != NULL, FALSE);
    g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (widget), FALSE);
    g_return_val_if_fail (event != NULL, FALSE);
  
    self = GTK_IMAGE_VIEWER (widget);
  
    if (event->is_hint) {
       gdk_window_get_pointer(event->window, &x, &y, &state);
    } else {
       x = (int) event->x;
       y = (int) event->y;
    }
    selfp->last_x = x;
    selfp->last_y = y;
  
    if (selfp->is_mouse_button2_pressed)
      {
        if (selfp->last_pan_anchor_x>0 && selfp->last_pan_anchor_y > 0)
          {
            int dx = (int)(selfp->last_pan_anchor_x-x);
            int dy = (int)(selfp->last_pan_anchor_y-y);

            if (selfp->do_flip_horizontal)
              dx = -dx;
            if (selfp->do_flip_vertical)
              dy = -dy;
            zoom_translate(self, dx, dy);
          }
        
        selfp->last_pan_anchor_x = x;
        selfp->last_pan_anchor_y = y;
  
        return TRUE;
      }
    
    return FALSE;
  }}
#line 1033 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 530 "src/gtk-image-viewer.gob"
static gint 
___f_gtk_image_viewer_scroll_event (GtkWidget * widget, GdkEventScroll * event)
#line 1040 "gtk-image-viewer.cc"
#define PARENT_HANDLER(___widget,___event) \
	((GTK_WIDGET_CLASS(parent_class)->scroll_event)? \
		(* GTK_WIDGET_CLASS(parent_class)->scroll_event)(___widget,___event): \
		((gint )0))
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::scroll_event"
{
#line 534 "src/gtk-image-viewer.gob"
	
    GtkImageViewer *self = GTK_IMAGE_VIEWER(widget);
    /* Add the following in order only to get control scroll.
    if (event->state & GDK_CONTROL_MASK)
     */
    {
      gdouble x = event->x;
      gdouble y = event->y;
      if (event->direction)
          //zoom_in(self, (int)x,(int)y);
          zoom_out(self, (int)x,(int)y,1.1);
      else
          zoom_in(self, -1,-1,1.1);
      return 1;
    }
    return 0;
  }}
#line 1066 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__
#undef PARENT_HANDLER

#line 560 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_expose_area (GtkImageViewer * self, int exp_x0, int exp_y0, int w, int h)
#line 1073 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::expose_area"
#line 560 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 560 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 1080 "gtk-image-viewer.cc"
{
#line 565 "src/gtk-image-viewer.gob"
	
    GtkWidget *widget = GTK_WIDGET(self); /* In order to access window */
    GdkPixbuf *img_scaled = NULL;
    double scale_x = selfp->current_scale_x;
    double scale_y = selfp->current_scale_y;
    int exp_x1 = exp_x0 + w;
    int exp_y1 = exp_y0 + h;
    int offs_x = -selfp->current_x0-exp_x0;
    int offs_y = -selfp->current_y0-exp_y0;
    int trans_offs_x = offs_x;
    int trans_offs_y = offs_y;
    int dst_x = exp_x0;
    int dst_y = exp_y0;
    int copy_w = w;
    int copy_h = h;
    int cnv_w = selfp->canvas_width;
    int cnv_h = selfp->canvas_height;

    // This doesn't work yet. If the adjustments changed then there
    // is no reason to expose.
    if (update_adjustments(self))
      return;

#if 0
    printf("Expose area %d %d %d %d\n",
           exp_x0, exp_y0, w, h);
#endif

    // Check if we have a cached version of the exposed area and
    // that the settings of the cache match the current settings.
    if (selfp->cache_area) {
        if (selfp->cache_scale_x == scale_x
            && selfp->cache_scale_y == scale_y
            && selfp->cache_current_x0 == selfp->current_x0
            && selfp->cache_current_y0 == selfp->current_y0
            && selfp->cache_width == selfp->canvas_width
            && selfp->cache_height == selfp->canvas_height
            ) {

#if 0
            printf("Restoring cache!\n");
#endif
            /* Scroll visible region */
            gdk_draw_drawable (widget->window,
                               selfp->gc,
                               selfp->cache_area,
                               exp_x0, exp_y0,
                               exp_x0, exp_y0,
                               w,h);
            return;
        }
        else {
            // invalidate cache
            gdk_drawable_unref(selfp->cache_area);
            selfp->cache_area = NULL;
        }
    }

    if (selfp->image)
      {
  				/* Canvas size */
        int img_w, img_h;		/* Image's size (pixels) */
        int img_x0 = 0;
        int img_x1 = cnv_w;
        int img_y0 = 0;
        int img_y1 = cnv_h;
        img_w = gdk_pixbuf_get_width(selfp->image);
        img_h = gdk_pixbuf_get_height(selfp->image);
        DBG(fprintf(stderr, "current_x0 exp_x0 offs_x = %d %d %d\n",
                    selfp->current_x0,
                    exp_x0,
                    offs_x));
  
        /* If img fits in canvas horizontally, need a smaller drawing zone */
        if (img_w * scale_x < cnv_w) 
          {
            img_x0 = (int)((cnv_w - img_w*scale_x)/2);
            img_x1 = (int)(img_x0 + img_w*scale_x);
          }
        
        /* If img fits in canvas vertically : need a smaller drawing zone */
        if (img_h * scale_y < cnv_h)
          {
            img_y0 = (int)((cnv_h - img_h*scale_y)/2);
            img_y1 = (int)(img_y0 + img_h*scale_y);
          }
        
        if (exp_x1 < img_x0)
          {
            DBG(fprintf(stderr, "Case 1X\n"));
            copy_w = 0;
            offs_x = 0;
            dst_x = img_x0;
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
          }
        else if (exp_x0 < img_x0 && exp_x1 > img_x1)
          {
            DBG(fprintf(stderr, "Case 2X\n"));
            copy_w = w - (img_x0 - exp_x0) - (exp_x1 - img_x1);
            dst_x = img_x0;

            if (selfp->do_flip_horizontal)
              {
                trans_offs_x = selfp->current_x0+exp_x0+cnv_w-img_x0;
                offs_x = 0;
              }
            else
              trans_offs_x = offs_x = 0;
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,(img_x0-exp_x0), h);
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               img_x1,exp_y0,(exp_x1-img_x1), h);
          }
        else if (exp_x0 < img_x0)
          {
            DBG(fprintf(stderr, "Case 3X\n"));
            copy_w = w - (img_x0 - exp_x0);
            dst_x = img_x0;

            if (selfp->do_flip_horizontal)
              {
                offs_x = (int)(-(img_w*scale_x-(exp_x1-img_x0)));
                trans_offs_x = selfp->current_x0+cnv_w-img_x0;
              }
            else
              offs_x = trans_offs_x = 0;
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,(img_x0-exp_x0), h);
          }
        else if (exp_x0 > img_x1)
          {
            DBG(fprintf(stderr, "Case 4X\n"));
            copy_w = 0;
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
            
          }
        else if (exp_x1 > img_x1)
          {
            DBG(fprintf(stderr, "Case 5X\n"));
            copy_w = w - (exp_x1 - img_x1);
            dst_x = exp_x0;

            if (selfp->do_flip_horizontal)
              {
                trans_offs_x = selfp->current_x0-exp_x0+cnv_w;
                offs_x = 0;
              }
            else
              offs_x = trans_offs_x = -(exp_x0-img_x0);
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               img_x1,exp_y0,exp_x1-img_x1, h);
          }
        else
          {
            DBG(fprintf(stderr, "Case 6X\n"));
            dst_x = exp_x0;
            copy_w = w;
            
            if (selfp->do_flip_horizontal)
              {
                offs_x = -(cnv_w + selfp->current_x0 - exp_x1);
                trans_offs_x = selfp->current_x0-exp_x0+cnv_w;
              }
            else
              offs_x = trans_offs_x = -selfp->current_x0-exp_x0;
          }
  
        /* Y dir */
        if (exp_y1 < img_y0)
          {
            DBG(fprintf(stderr, "Case 1Y\n"));
            copy_h = 0;
            offs_y = 0;
            dst_x = img_y0;
            gdk_draw_rectangle(widget->window,
  			     widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
          }
        else if (exp_y0 < img_y0 && exp_y1 > img_y1)
          {
            DBG(fprintf(stderr, "Case 2Y\n"));
            copy_h = h - (img_y0 - exp_y0) - (exp_y1 - img_y1);
            dst_y = img_y0;
            
            if (selfp->do_flip_vertical)
              {
                trans_offs_y = selfp->current_y0+exp_y0+cnv_h-img_y0;
                offs_y = 0;
              }
            else
              trans_offs_y = offs_y = 0;
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, img_y0-exp_y0);
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0, img_y1,w, exp_y1-img_y1);
          }
        else if (exp_y0 < img_y0)
          {
            DBG(fprintf(stderr, "Case 3Y\n"));
            copy_h = h - (img_y0 - exp_y0);
            dst_y = img_y0;
            
            if (selfp->do_flip_vertical)
              {
                offs_y = (int)(-(img_h*scale_y-(exp_y1-img_y0)));
                trans_offs_y = selfp->current_y0+cnv_h-img_y0;
              }
            else
              offs_y = trans_offs_y = 0;

            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w,(img_y0-exp_y0));
          }
        else if (exp_y0 > img_y1)
          {
            DBG(fprintf(stderr, "Case 4Y\n"));
            copy_h = 0;
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,exp_y0,w, h);
            
          }
        else if (exp_y1 > img_y1)
          {
            DBG(fprintf(stderr, "Case 5Y\n"));
            copy_h = h - (exp_y1 - img_y1);
            dst_y = exp_y0;

            if (selfp->do_flip_vertical)
              {
                trans_offs_y = selfp->current_y0-exp_y0+cnv_h;
                offs_y = 0;
              }
            else
              offs_y = trans_offs_y = -(exp_y0-img_y0);
            
            gdk_draw_rectangle(widget->window,
                               widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                               TRUE,
                               exp_x0,img_y1,w,exp_y1-img_y1);
          }
        else
          {
            DBG(fprintf(stderr, "Case 6Y\n"));
            dst_y = exp_y0;
            copy_h = h;

            if (selfp->do_flip_vertical)
              {
                offs_y = -(cnv_h + selfp->current_y0 - exp_y1);
                trans_offs_y = selfp->current_y0-exp_y0+cnv_h;
              }
            else
              offs_y = trans_offs_y = -selfp->current_y0-exp_y0;
          }
        
  
        DBG(fprintf(stderr, "dst_x dst_y copy_w copy_h offs_x offs_y = %d %d %d %d %d %d\n",
  	      dst_x, dst_y, copy_w, copy_h,
  	      selfp->current_x0, selfp->current_y0));
        /* Scale and copy the image */
        if (copy_w > 0 && copy_h > 0)
          {
            img_scaled = gdk_pixbuf_new(gdk_pixbuf_get_colorspace(selfp->image),
                                        TRUE,
                                        gdk_pixbuf_get_bits_per_sample(selfp->image),
                                        copy_w, copy_h);

#if 0
            if (selfp->do_flip_horizontal*0)
              {
                DBG(printf("old: offs_x w*scale_x exp_x0 current_x0 cnv_w=%d %f %d %d %d\n",
                           offs_x, w*scale_x, exp_x0, selfp->current_x0, cnv_w));

#if 0
                offs_x = -selfp->current_x0-(cnv_w-exp_x1);
                if (w * scale_x < cnv_w)
                  offs_x -= (cnv_w - w*scale_x)/2;
#endif
                offs_x = cnv_w+offs_x - (exp_x1-exp_x0);
                DBG(printf("b4 adj offs_x cnv_w img_w*scale_x cnv_w-img_w*scale_x= %d %d %.1f %.1f\n", offs_x, cnv_w, img_w*scale_x, cnv_w - img_w*scale_x));
                if (img_w * scale_x < cnv_w)
                  offs_x -= (cnv_w - img_w*scale_x)/2;
                    
                DBG(printf("new_offs_x=%d\n", offs_x));
              }
            if (selfp->do_flip_vertical)
              offs_y = -selfp->current_x0-(cnv_h-exp_x1);
#endif
            
            /* Check legality */
            DBG(fprintf(stderr, "offs_x copy_x scale_x w = %d %d %f %d\n",
                        offs_x, copy_w, scale_x, img_w));
            gdk_pixbuf_scale(selfp->image,
                             img_scaled,
                             0,0,
                             copy_w,
                             copy_h,
                             offs_x,
                             offs_y,
                             scale_x, scale_y,
                             selfp->interp_type);
            
            if (selfp->do_use_transfer_map)
              {
                /* Assume we are doing 8-bit... */
                guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
                gint w = gdk_pixbuf_get_width(img_scaled);
                gint h = gdk_pixbuf_get_height(img_scaled);
                gint rs = gdk_pixbuf_get_rowstride(img_scaled);
                gint row_idx, col_idx;
                guint8 *rmap = selfp->transfer_map[0];
                guint8 *gmap = selfp->transfer_map[1];
                guint8 *bmap = selfp->transfer_map[2];
                
                for (row_idx=0; row_idx<h; row_idx++)
                  {
                    guint8 *p = &buf_scaled[rs*row_idx];
                    
                    for (col_idx=0; col_idx<w; col_idx++)
                      {
                        *p = rmap[*p]; p++;
                        *p = gmap[*p]; p++;
                        *p = bmap[*p]; p++;
                      }
                  }
              }
            
            if (selfp->do_flip_vertical)
              {
                /* Assume we are doing 8-bit... */
                guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
                gint w = gdk_pixbuf_get_width(img_scaled);
                gint h = gdk_pixbuf_get_height(img_scaled);
                gint rs = gdk_pixbuf_get_rowstride(img_scaled);
                gint row_idx, col_idx;
                
                for (row_idx=0; row_idx<h/2; row_idx++)
                  {
                    guint8 *ptr1 = buf_scaled+rs * row_idx;
                    guint8 *ptr2 = buf_scaled+rs * (h-row_idx-1);
                    
                    for (col_idx=0; col_idx<w; col_idx++)
                      {
                        guint8 tmp_r = *ptr1;
                        guint8 tmp_g = *(ptr1+1);
                        guint8 tmp_b = *(ptr1+2);
                        guint8 tmp_alpha = *(ptr1+3);
                        *ptr1++ = *ptr2;
                        *ptr1++ = *(ptr2+1);
                        *ptr1++ = *(ptr2+2);
                        *ptr1++ = *(ptr2+3);
                        *ptr2++ = tmp_r;
                        *ptr2++ = tmp_g;
                        *ptr2++ = tmp_b;
                        *ptr2++ = tmp_alpha;
                      }
                  }
              }
            
            if (selfp->do_flip_horizontal)
              {
  	      /* Assume we are doing 8-bit... */
  	      guint8 *buf_scaled = gdk_pixbuf_get_pixels(img_scaled);
  	      gint w = gdk_pixbuf_get_width(img_scaled);
  	      gint h = gdk_pixbuf_get_height(img_scaled);
  	      gint rs = gdk_pixbuf_get_rowstride(img_scaled);
  	      gint row_idx, col_idx, clr_idx;
  	      
                for (col_idx = 0; col_idx < w/2; col_idx++)
                  {
                    for (row_idx = 0; row_idx <h; row_idx++)
                      {
                        int l_idx = row_idx * rs + col_idx*4;
                        int r_idx = row_idx * rs + (w - col_idx - 1)*4;
                        
                        for (clr_idx=0; clr_idx<4; clr_idx++)
                          {
                            guint8 tmp = buf_scaled[l_idx+clr_idx];
                            buf_scaled[l_idx+clr_idx] = buf_scaled[r_idx+clr_idx];
                            buf_scaled[r_idx+clr_idx] = tmp;
                          }
                      }
                  }
              }


  	}
      }

    // If we are working without a background image then create one
    // now for the painting.
    if (!img_scaled)
      {
        img_scaled = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
                                    TRUE,
                                    8,
                                    w, h);
        if (selfp->do_flip_horizontal)
          offs_x = selfp->current_x0+w-exp_x1+cnv_w;
        else
          offs_x = -selfp->current_x0-exp_x0;
        DBG(printf("No image: current_x0=%d offs_x = %d\n", selfp->current_x0, offs_x));
        if (selfp->do_flip_vertical)
          offs_y = selfp->current_y0+h-exp_y1+cnv_h;
        else
          offs_y = -selfp->current_y0-exp_y0;
        dst_x = exp_x0;
        dst_y = exp_y0;
        copy_w = w;
        copy_h = h;

        gdk_pixbuf_fill(img_scaled,
                        0xffffffff);
    }
    else
      {
        offs_x = trans_offs_x;
        offs_y = trans_offs_y;
      }
          
    // Image annotation signal
#if 0
    printf("preparing for emit. frozen = %d\n",
           selfp->frozen);
#endif
    if (!selfp->frozen) {
        GValue ___param_values[6];
        GValue ___return_val;

        int signal_shift_x = offs_x;
        int signal_shift_y = offs_y;
        double signal_scale_x = scale_x;
        double signal_scale_y = scale_y;

        // Flip the scale and shift if we are flipped
        if (selfp->do_flip_horizontal)
          signal_scale_x = -signal_scale_x;
        if (selfp->do_flip_vertical)
          signal_scale_y = -signal_scale_y;
              
        memset (&___return_val, 0, sizeof (___return_val));
        memset (&___param_values, 0, sizeof (___param_values));
        
        ___param_values[0].g_type = 0;
        g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
        g_value_set_instance (&___param_values[0], (gpointer) self);
        
        ___param_values[1].g_type = 0;
        g_value_init (&___param_values[1], G_TYPE_POINTER);
        g_value_set_pointer (&___param_values[1], img_scaled);
        
        ___param_values[2].g_type = 0;
        g_value_init (&___param_values[2], G_TYPE_INT);
        g_value_set_int (&___param_values[2], -signal_shift_x);
        
        ___param_values[3].g_type = 0;
        g_value_init (&___param_values[3], G_TYPE_INT);
        g_value_set_int (&___param_values[3], -signal_shift_y);
        
        ___param_values[4].g_type = 0;
        g_value_init (&___param_values[4], G_TYPE_DOUBLE);
        g_value_set_double (&___param_values[4], signal_scale_x);
        
        ___param_values[5].g_type = 0;
        g_value_init (&___param_values[5], G_TYPE_DOUBLE);
        g_value_set_double (&___param_values[5], signal_scale_y);
        
        //        printf("Emitting!\n");
        g_signal_emitv (___param_values,
                        object_signals[IMAGE_ANNOTATE_SIGNAL],
                        0 /* detail */,
                        &___return_val);
        
        //printf("Done emitting!\n");
        for (int i=0; i<6; i++)
            g_value_unset (&___param_values[i]);
    }

    // Add checkerboard below images that have alpha channel
    if (gdk_pixbuf_get_has_alpha(img_scaled)) {
        GdkPixbuf *img_comp = gdk_pixbuf_new(gdk_pixbuf_get_colorspace(img_scaled),
                                             TRUE,
                                             gdk_pixbuf_get_bits_per_sample(img_scaled),
                                             copy_w, copy_h);
        gdk_pixbuf_composite_color(img_scaled,
                                   img_comp,
                                   0,0,
                                   copy_w, copy_h,
                                   0,0,
                                   1.0,1.0,
                                   GDK_INTERP_NEAREST,
                                   255,
                                   -(int)offs_x,
                                   -(int)offs_y,
                                   16,
                                   0xff505050,
                                   0xffa0a0a0
                                   );
        gdk_pixbuf_unref(img_scaled);
        img_scaled = img_comp;
    }
    if (!selfp->frozen)
      gdk_draw_pixbuf (widget->window,
                       widget->style->bg_gc[GTK_WIDGET_STATE (widget)],
                       img_scaled,
                       0, 0,
                       dst_x, dst_y,
                       copy_w, copy_h,
                       GDK_RGB_DITHER_NORMAL,
                       selfp->current_x0,
                       selfp->current_y0);
    
    gdk_pixbuf_unref(img_scaled);

    // If we have just drawn the whole buffer, then copy the result
    // to the cache.
    if (w == selfp->canvas_width
        && h == selfp->canvas_height) {
        selfp->cache_area = gdk_pixmap_new(widget->window,
                                           w,h,
                                           -1);
        if (!selfp->gc) {
            selfp->gc = gdk_gc_new(widget->window);
            gdk_gc_copy(selfp->gc, widget->style->white_gc);
            gdk_gc_set_exposures(selfp->gc, TRUE);
	}

        gdk_draw_drawable(selfp->cache_area,
                          selfp->gc,
                          widget->window,
                          0,0,
                          0,0,
                          -1, -1);
        selfp->cache_current_x0 = selfp->current_x0;
        selfp->cache_current_y0 = selfp->current_y0;
        selfp->cache_scale_x = selfp->current_scale_x;
        selfp->cache_scale_y = selfp->current_scale_y;
        selfp->cache_width = selfp->canvas_width;
        selfp->cache_height = selfp->canvas_height;
#if 0
        printf("Storing cache! (x0,y0,sx,sy) = (%d %d %f %f)\n",
               selfp->current_x0, selfp->current_y0,
               selfp->current_scale_x, selfp->current_scale_y);
#endif
    }
  
#if 0
    gtk_signal_emit(GTK_OBJECT(self), gtk_image_viewer_signals[VIEW_CHANGED]);
#endif
  }}
#line 1660 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1143 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_freeze (GtkImageViewer * self, gboolean is_frozen)
#line 1666 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_freeze"
#line 1143 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1143 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 1673 "gtk-image-viewer.cc"
{
#line 1146 "src/gtk-image-viewer.gob"
	
    selfp->frozen = is_frozen;
    if (!selfp->frozen)
      gtk_image_viewer_redraw(self,
                              true);
  }}
#line 1682 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1153 "src/gtk-image-viewer.gob"
gint 
gtk_image_viewer_redraw (GtkImageViewer * self, gboolean clear_cache)
#line 1688 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::redraw"
#line 1153 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 1153 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), (gint )0);
#line 1695 "gtk-image-viewer.cc"
{
#line 1157 "src/gtk-image-viewer.gob"
	
    if (clear_cache) {
      if (selfp->cache_area) 
        gdk_drawable_unref(selfp->cache_area);
      selfp->cache_area = NULL;
    }
    if (GTK_WIDGET(self)->window)
      gtk_image_viewer_expose_area(self,
                                   0,0,
                                   GTK_WIDGET(self)->allocation.width,
                                   GTK_WIDGET(self)->allocation.height);
    return FALSE;
  }}
#line 1711 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1178 "src/gtk-image-viewer.gob"
gint 
gtk_image_viewer_zoom_around_fixed_point (GtkImageViewer * self, double new_scale_x, double new_scale_y, double old_x, double old_y, double new_x, double new_y)
#line 1717 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::zoom_around_fixed_point"
#line 1178 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 1178 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), (gint )0);
#line 1724 "gtk-image-viewer.cc"
{
#line 1187 "src/gtk-image-viewer.gob"
	
      double w = selfp->canvas_width;
      double h = selfp->canvas_height;
      double old_scale_x, old_scale_y, old_x0, old_y0, new_x0, new_y0;
      DBG(printf("zoom_around_fixed_point: nsx nsy old_x old_y new_x new_y = %f %f  %f %f  %f %f\n",
                 new_scale_x, new_scale_y,
                 old_x, old_y,
                 new_x, new_y));
      
      g_return_val_if_fail (self != NULL, FALSE);
      g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), FALSE);
      
      /* Short cuts */
      old_x0 = selfp->current_x0;
      old_y0 = selfp->current_y0;
      old_scale_x = selfp->current_scale_x;
      old_scale_y = selfp->current_scale_y;
      
      
      if (selfp->do_flip_horizontal) {
          old_x = w - old_x;
          new_x = w - new_x;
      }
      if (selfp->do_flip_vertical) {
          old_y = h - old_y;
          new_y = h - new_y;
      }
      
      new_x0 = new_scale_x/old_scale_x * (old_x + old_x0) - new_x;
      new_y0 = new_scale_y/old_scale_y * (old_y + old_y0) - new_y;
      
      DBG(printf("old_x0 new_x0 = %f %f\n", old_x0, new_x0));
      view_changed(self, FALSE, new_scale_x, new_scale_y, new_x0, new_y0);
      
      return 0;
  }}
#line 1763 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1224 "src/gtk-image-viewer.gob"
gint 
gtk_image_viewer_zoom_to_box (GtkImageViewer * self, double world_min_x, double world_min_y, double world_max_x, double world_max_y, double pixel_margin, gboolean preserve_aspect)
#line 1769 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::zoom_to_box"
#line 1224 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (self != NULL, (gint )0);
#line 1224 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), (gint )0);
#line 1776 "gtk-image-viewer.cc"
{
#line 1232 "src/gtk-image-viewer.gob"
	
      double w = selfp->canvas_width;
      double h = selfp->canvas_height;
#if 0
      printf("alloc_width=%f alloc_height=%f\n",
             w,h);
#endif
      double new_scale_x = (w-2*pixel_margin)/(world_max_x-world_min_x);
      double new_scale_y = (h-2*pixel_margin)/(world_max_y-world_min_y);
      
      if (preserve_aspect) {
          if (new_scale_x > new_scale_y)
              new_scale_x = new_scale_y;
          else
              new_scale_y = new_scale_x;
      }
      // This works for both flip and not flip!
      double new_x0 = new_scale_x*0.5*(world_max_x+world_min_x)-w/2;
      double new_y0 = new_scale_y*0.5*(world_max_y+world_min_y)-h/2;

      view_changed(self, FALSE, new_scale_x, new_scale_y, new_x0, new_y0);
      
      return 0;
  }}
#line 1803 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1264 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_hadjustment (GtkImageViewer * self, GtkAdjustment * adjustment)
#line 1809 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_hadjustment"
#line 1264 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1264 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 1816 "gtk-image-viewer.cc"
{
#line 1267 "src/gtk-image-viewer.gob"
	
    g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
    if (adjustment) {
        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
    }
  
    if (selfp->hadjustment && selfp->hadjustment != adjustment)
      {
        gtk_signal_disconnect_by_data (GTK_OBJECT (selfp->hadjustment), self);
        gtk_object_unref (GTK_OBJECT (selfp->hadjustment));
        selfp->hadjustment = NULL;
      }
  
    if (!adjustment)
      adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0,
  						     0.0, 0.0, 0.0));
  
    if (selfp->hadjustment != adjustment)
      {
        selfp->hadjustment = adjustment;
        gtk_object_ref (GTK_OBJECT (selfp->hadjustment));
        gtk_object_sink (GTK_OBJECT (selfp->hadjustment));
        
        gtk_signal_connect (GTK_OBJECT (adjustment), "value_changed",
  			  G_CALLBACK(hadjustment_value_changed),
  			  (gpointer) self);
      }
  
    //    g_object_notify (G_OBJECT (self), "hadjustment");
  }}
#line 1849 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1305 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_vadjustment (GtkImageViewer * self, GtkAdjustment * adjustment)
#line 1855 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_vadjustment"
#line 1305 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1305 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 1862 "gtk-image-viewer.cc"
{
#line 1309 "src/gtk-image-viewer.gob"
	
    g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
    if (adjustment) {
        g_return_if_fail (GTK_IS_ADJUSTMENT (adjustment));
    }
  
    if (selfp->vadjustment && selfp->vadjustment != adjustment)
      {
        gtk_signal_disconnect_by_data (GTK_OBJECT (selfp->vadjustment), self);
        gtk_object_unref (GTK_OBJECT (selfp->vadjustment));
        selfp->vadjustment = NULL;
      }
  
    if (!adjustment)
      adjustment = GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.0, 0.0,
  						     0.0, 0.0, 0.0));
  
    if (selfp->vadjustment != adjustment)
      {
        selfp->vadjustment = adjustment;
        gtk_object_ref (GTK_OBJECT (selfp->vadjustment));
        gtk_object_sink (GTK_OBJECT (selfp->vadjustment));
        
        gtk_signal_connect (GTK_OBJECT (adjustment), "value_changed",
  			  G_CALLBACK(vadjustment_value_changed),
  			  (gpointer) self);
      }
  
    // g_object_notify (G_OBJECT (self), "vadjustment");
    update_adjustments(self);
  }}
#line 1896 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1341 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_image (GtkImageViewer * self, GdkPixbuf * image)
#line 1902 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_image"
#line 1341 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1341 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 1909 "gtk-image-viewer.cc"
{
#line 1345 "src/gtk-image-viewer.gob"
	
    if (selfp->image)
      gdk_pixbuf_unref(selfp->image);
    selfp->image = image;

    if (image)
      {
        gdk_pixbuf_ref(image);
        selfp->scroll_min_x = 0;
        selfp->scroll_min_y = 0;
        selfp->scroll_width = gdk_pixbuf_get_width(image);
        selfp->scroll_height = gdk_pixbuf_get_height(image);
        selfp->scroll_max_x = selfp->scroll_width;
        selfp->scroll_max_y = selfp->scroll_height;
      }

    gtk_image_viewer_redraw(self, true);
  }}
#line 1930 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1364 "src/gtk-image-viewer.gob"
const GdkPixbuf * 
gtk_image_viewer_get_image (GtkImageViewer * self)
#line 1936 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::get_image"
#line 1364 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (self != NULL, (const GdkPixbuf * )0);
#line 1364 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), (const GdkPixbuf * )0);
#line 1943 "gtk-image-viewer.cc"
{
#line 1367 "src/gtk-image-viewer.gob"
	
    return selfp->image;
  }}
#line 1949 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1371 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_scroll_adjustments (GtkImageViewer * self, GtkAdjustment * hadjustment, GtkAdjustment * vadjustment)
#line 1955 "gtk-image-viewer.cc"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 1371 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1371 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 1967 "gtk-image-viewer.cc"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_OBJECT);
	g_value_set_object (&___param_values[1], (GObject *) hadjustment);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_OBJECT);
	g_value_set_object (&___param_values[2], (GObject *) vadjustment);

	g_signal_emitv (___param_values,
		object_signals[SET_SCROLL_ADJUSTMENTS_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}
#line 1371 "src/gtk-image-viewer.gob"
static void 
___real_gtk_image_viewer_set_scroll_adjustments (GtkImageViewer * self, GtkAdjustment * hadjustment, GtkAdjustment * vadjustment)
#line 1993 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_scroll_adjustments"
	if (&self) { ; }
{
#line 1376 "src/gtk-image-viewer.gob"
	
    if (selfp->hadjustment != hadjustment)
      gtk_image_viewer_set_hadjustment (self, hadjustment);
    if (selfp->vadjustment != vadjustment)
      gtk_image_viewer_set_vadjustment (self, vadjustment);
  }}
#line 2005 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1383 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_image_annotate (GtkImageViewer * self, GdkPixbuf * pixbuf, gint shift_x, gint shift_y, gdouble scale_x, gdouble scale_y)
#line 2011 "gtk-image-viewer.cc"
{
	GValue ___param_values[6];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 1383 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1383 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2023 "gtk-image-viewer.cc"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_POINTER);
	g_value_set_pointer (&___param_values[1], (gpointer ) pixbuf);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_INT);
	g_value_set_int (&___param_values[2], (gint ) shift_x);

	___param_values[3].g_type = 0;
	g_value_init (&___param_values[3], G_TYPE_INT);
	g_value_set_int (&___param_values[3], (gint ) shift_y);

	___param_values[4].g_type = 0;
	g_value_init (&___param_values[4], G_TYPE_DOUBLE);
	g_value_set_double (&___param_values[4], (gdouble ) scale_x);

	___param_values[5].g_type = 0;
	g_value_init (&___param_values[5], G_TYPE_DOUBLE);
	g_value_set_double (&___param_values[5], (gdouble ) scale_y);

	g_signal_emitv (___param_values,
		object_signals[IMAGE_ANNOTATE_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
	g_value_unset (&___param_values[3]);
	g_value_unset (&___param_values[4]);
	g_value_unset (&___param_values[5]);
}

#line 1390 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_flip_changed (GtkImageViewer * self, gboolean horizontal_flip, gboolean vertical_flip)
#line 2065 "gtk-image-viewer.cc"
{
	GValue ___param_values[3];
	GValue ___return_val;

memset (&___return_val, 0, sizeof (___return_val));
memset (&___param_values, 0, sizeof (___param_values));

#line 1390 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1390 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2077 "gtk-image-viewer.cc"

	___param_values[0].g_type = 0;
	g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
	g_value_set_instance (&___param_values[0], (gpointer) self);

	___param_values[1].g_type = 0;
	g_value_init (&___param_values[1], G_TYPE_INT);
	g_value_set_int (&___param_values[1], (gint ) horizontal_flip);

	___param_values[2].g_type = 0;
	g_value_init (&___param_values[2], G_TYPE_INT);
	g_value_set_int (&___param_values[2], (gint ) vertical_flip);

	g_signal_emitv (___param_values,
		object_signals[FLIP_CHANGED_SIGNAL],
		0 /* detail */,
		&___return_val);

	g_value_unset (&___param_values[0]);
	g_value_unset (&___param_values[1]);
	g_value_unset (&___param_values[2]);
}

#line 1396 "src/gtk-image-viewer.gob"
guint 
gtk_image_viewer_get_image_width (GtkImageViewer * self)
#line 2104 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::get_image_width"
{
#line 1399 "src/gtk-image-viewer.gob"
	 
    return gdk_pixbuf_get_width (selfp->image);
  }}
#line 2112 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1403 "src/gtk-image-viewer.gob"
guint 
gtk_image_viewer_get_image_height (GtkImageViewer * self)
#line 2118 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::get_image_height"
{
#line 1405 "src/gtk-image-viewer.gob"
	 
    return gdk_pixbuf_get_height (selfp->image);
  }}
#line 2126 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1409 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_canv_coord_to_img_coord (GtkImageViewer * self, double cx, double cy, double * imgx, double * imgy)
#line 2132 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::canv_coord_to_img_coord"
#line 1409 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1409 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2139 "gtk-image-viewer.cc"
{
#line 1414 "src/gtk-image-viewer.gob"
	
    if (selfp->do_flip_horizontal) {
        int w = selfp->canvas_width;
        *imgx = (selfp->current_x0+w-cx)/selfp->current_scale_x;
    }
    else
      *imgx=(selfp->current_x0+cx)/selfp->current_scale_x;

    if (selfp->do_flip_vertical) {
        int h = selfp->canvas_height;
        *imgy = (selfp->current_y0+h-cy)/selfp->current_scale_y;
    }
    else
      *imgy=(selfp->current_y0+cy)/selfp->current_scale_y;

#if 0
    if (selfp->do_flip_vertical)
      *imgy = -(cy-selfp->current_y0-GTK_WIDGET(self)->allocation.height)/selfp->current_scale_y;
    else
      *imgy=(cy+selfp->current_y0)/selfp->current_scale_y;
#endif
  }}
#line 2164 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1437 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_img_coord_to_canv_coord (GtkImageViewer * self, double imgx, double imgy, double * canvx, double * canvy)
#line 2170 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::img_coord_to_canv_coord"
#line 1437 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1437 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2177 "gtk-image-viewer.cc"
{
#line 1442 "src/gtk-image-viewer.gob"
	
    if (selfp->do_flip_horizontal) {
        int w = selfp->canvas_width;
        *canvx = (selfp->current_x0+w-imgx*selfp->current_scale_x);
    }
    else
      *canvx = imgx*selfp->current_scale_x-selfp->current_x0;
    
    
    if (selfp->do_flip_vertical) {
        int h = selfp->canvas_height;
        *canvy = (selfp->current_y0+h-imgy*selfp->current_scale_y);
    }
    else
      *canvy = imgy*selfp->current_scale_y-selfp->current_y0;
  }}
#line 2196 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1459 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_zoom_range (GtkImageViewer * self, double min_zoom, double max_zoom)
#line 2202 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_zoom_range"
#line 1459 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1459 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2209 "gtk-image-viewer.cc"
{
#line 1463 "src/gtk-image-viewer.gob"
	
      selfp->min_zoom = min_zoom;
      selfp->max_zoom = max_zoom;
  }}
#line 2216 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1468 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_get_scale_and_shift (GtkImageViewer * self, gdouble * scale_x, gdouble * scale_y, gint * shift_x, gint * shift_y)
#line 2222 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::get_scale_and_shift"
#line 1468 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1468 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2229 "gtk-image-viewer.cc"
{
#line 1474 "src/gtk-image-viewer.gob"
	
    *scale_x = selfp->current_scale_x;
    *scale_y = selfp->current_scale_y;
    *shift_x = selfp->current_x0;
    *shift_y = selfp->current_y0;
    if (selfp->do_flip_horizontal) {
        int cnv_w = selfp->canvas_width;
        *scale_x = -*scale_x;
        *shift_x += cnv_w;
        *shift_x = -*shift_x;
    }
    if (selfp->do_flip_vertical) {
        int cnv_h = selfp->canvas_height;
        *scale_y = -*scale_y;
        *shift_y += cnv_h;
        *shift_y = -*shift_y;
    }
  }}
#line 2250 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1493 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_transfer_map (GtkImageViewer * self, guint8 * rmap, guint8 * gmap, guint8 * bmap)
#line 2256 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_transfer_map"
#line 1493 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1493 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2263 "gtk-image-viewer.cc"
}
#undef __GOB_FUNCTION__

#line 1501 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_fill_on_resize (GtkImageViewer * self, gboolean whether)
#line 2270 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_fill_on_resize"
#line 1501 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1501 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2277 "gtk-image-viewer.cc"
{
#line 1504 "src/gtk-image-viewer.gob"
	
      selfp->do_fill_on_resize = whether;
  }}
#line 2283 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1508 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_one_shot_block_fill_on_resize (GtkImageViewer * self)
#line 2289 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::one_shot_block_fill_on_resize"
#line 1508 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1508 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2296 "gtk-image-viewer.cc"
{
#line 1510 "src/gtk-image-viewer.gob"
	
      selfp->one_shot_block_fill_on_resize = true;
  }}
#line 2302 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1514 "src/gtk-image-viewer.gob"
gboolean 
gtk_image_viewer_get_fill_on_resize (GtkImageViewer * self)
#line 2308 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::get_fill_on_resize"
#line 1514 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (self != NULL, (gboolean )0);
#line 1514 "src/gtk-image-viewer.gob"
	g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), (gboolean )0);
#line 2315 "gtk-image-viewer.cc"
{
#line 1516 "src/gtk-image-viewer.gob"
	
      return selfp->do_fill_on_resize;
  }}
#line 2321 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1520 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_scroll_region (GtkImageViewer * self, double x0, double y0, double x1, double y1)
#line 2327 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_scroll_region"
#line 1520 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1520 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2334 "gtk-image-viewer.cc"
{
#line 1524 "src/gtk-image-viewer.gob"
	
    selfp->scroll_min_x = x0;
    selfp->scroll_max_x = x1;
    selfp->scroll_min_y = y0;
    selfp->scroll_max_y = y1;
    selfp->scroll_width = x1-x0;
    selfp->scroll_height = y1-y0;

    update_adjustments(self);
  }}
#line 2347 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1535 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_set_flip (GtkImageViewer * self, gboolean do_flip_horizontal, gboolean do_flip_vertical)
#line 2353 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::set_flip"
#line 1535 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1535 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2360 "gtk-image-viewer.cc"
{
#line 1539 "src/gtk-image-viewer.gob"
	
    gboolean need_signal=false;

    // Flip adjustments
    if (do_flip_horizontal != selfp->do_flip_horizontal) {
      selfp->hadjustment->value = 1 - selfp->hadjustment->page_size - selfp->hadjustment->value;
      selfp->do_flip_horizontal = do_flip_horizontal;
      gtk_adjustment_value_changed(selfp->hadjustment);
      need_signal = true;
    }
    if (do_flip_vertical != selfp->do_flip_vertical) {
      selfp->vadjustment->value = 1 - selfp->vadjustment->page_size - selfp->vadjustment->value;
      selfp->do_flip_vertical = do_flip_vertical;
      gtk_adjustment_value_changed(selfp->vadjustment);
      need_signal =true;
    }

    if (need_signal)
      {
        // Emit flip signal
        {
          GValue ___param_values[3];
          GValue ___return_val;
          
          memset (&___return_val, 0, sizeof (___return_val));
          memset (&___param_values, 0, sizeof (___param_values));
          
          ___param_values[0].g_type = 0;
          g_value_init (&___param_values[0], G_TYPE_FROM_INSTANCE (self));
          g_value_set_instance (&___param_values[0], (gpointer) self);
          
          ___param_values[1].g_type = 0;
          g_value_init (&___param_values[1], G_TYPE_INT);
          g_value_set_int (&___param_values[1], selfp->do_flip_horizontal);
          
          ___param_values[2].g_type = 0;
          g_value_init (&___param_values[2], G_TYPE_INT);
          g_value_set_int (&___param_values[2], selfp->do_flip_vertical);
          
          g_signal_emitv (___param_values,
                          object_signals[FLIP_CHANGED_SIGNAL],
                          0 /* detail */,
                          &___return_val);
          
          for (int i=0; i<3; i++)
            g_value_unset (&___param_values[i]);
          
          gtk_image_viewer_redraw(self, true);
        }
      }
  }}
#line 2414 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1591 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_zoom_reset (GtkImageViewer * self)
#line 2420 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::zoom_reset"
#line 1591 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1591 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2427 "gtk-image-viewer.cc"
{
#line 1593 "src/gtk-image-viewer.gob"
	
      zoom_reset(self);
  }}
#line 2433 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1597 "src/gtk-image-viewer.gob"
void 
gtk_image_viewer_zoom_fit (GtkImageViewer * self)
#line 2439 "gtk-image-viewer.cc"
{
#define __GOB_FUNCTION__ "Gtk:Image:Viewer::zoom_fit"
#line 1597 "src/gtk-image-viewer.gob"
	g_return_if_fail (self != NULL);
#line 1597 "src/gtk-image-viewer.gob"
	g_return_if_fail (GTK_IS_IMAGE_VIEWER (self));
#line 2446 "gtk-image-viewer.cc"
{
#line 1599 "src/gtk-image-viewer.gob"
	
    gtk_image_viewer_zoom_to_box(self,
                                 selfp->scroll_min_x,
                                 selfp->scroll_min_y,
                                 selfp->scroll_max_x,
                                 selfp->scroll_max_y,
                                 0,
                                 TRUE);
  }}
#line 2458 "gtk-image-viewer.cc"
#undef __GOB_FUNCTION__

#line 1610 "src/gtk-image-viewer.gob"

/*======================================================================
//  view_changed does clipping, scrolling and scaling.
//----------------------------------------------------------------------
*/
static gint
view_changed(GtkImageViewer *self,
	     int do_force,
	     double scale_x, double scale_y, double x0, double y0)
{
  GtkWidget *widget = GTK_WIDGET(self);
  GdkPixbuf *im;
  int render_width, render_height;
  GdkRectangle expose_rect;
  //printf("view_changed\n");
  if (!widget || !widget->window)
    return 0;

  g_return_val_if_fail (self != NULL, FALSE);
  g_return_val_if_fail (GTK_IS_IMAGE_VIEWER (self), FALSE);

  widget = GTK_WIDGET(self);

  im = selfp->image; /* A short cut */

  DBG2(g_print("force sx sy x0 y0 = %d %f %f %f %f\n",
	       do_force, scale_x, scale_y, x0, y0));

  /* This should certainly be configurable */
  if (scale_x < 1.0)
    selfp->interp_type = GDK_INTERP_BILINEAR;
  else
    selfp->interp_type = GDK_INTERP_NEAREST;

  /* Clip the scale */
  if (selfp->max_zoom > 0 && scale_x>selfp->max_zoom && scale_y > selfp->max_zoom)
    return 0;
  else if (selfp->min_zoom > 0 && scale_x < selfp->min_zoom && scale_y < selfp->min_zoom)
    return 0;

  /* Clip the request */
  if (im
      || (selfp->scroll_width > 0 && selfp->scroll_height > 0)
      ) {
        int cwidth = selfp->canvas_width;
        int cheight = selfp->canvas_height;
        double height, width;
        
        width = selfp->scroll_width;
        height = selfp->scroll_height;
        
        if (im && width*scale_x > cwidth)
            render_width = cwidth;
        else
            render_width = (int)(width * scale_x);
        
        if (im && height*scale_y > cheight)
            render_height = cheight;
        else
            render_height = (int)(height * scale_y);
        
        // Clip only for images
        if (im) {
            if (render_width < cwidth)
                x0 = -(cwidth - render_width)/2;
            else if (x0 + render_width > width*scale_x)
                x0 = width*scale_x - render_width;
            else if (x0<0)
                x0 = 0;
            
            if (im && render_height < cheight)
                y0 = -(cheight - render_height)/2;
            else if (y0 + render_height > height*scale_y)
                y0 = height*scale_y - render_height;
            else if (y0<0)
                y0 = 0;
        }
  }
  
  /* If scale is the same, then the image has only been scrolled,
     and we only need to update the exposed areas.
   */
  if (!do_force
      && widget->window
      && scale_x == selfp->current_scale_x
      && scale_y == selfp->current_scale_y
      )
    {
      int dx = (int)(x0 - selfp->current_x0);
      int dy = (int)(y0 - selfp->current_y0);

      // Scroll in opposite direction if we are flipping
      if (selfp->do_flip_horizontal)
        dx = -dx;
      if (selfp->do_flip_vertical)
        dy = -dy;
      int src_x = (dx < 0) ? 0 : dx;
      int src_y = (dy < 0) ? 0 : dy;
      int dst_x = (dx < 0) ? -dx : 0;
      int dst_y = (dy < 0) ? -dy : 0;

      /* Construct the gc the first time it is used */
      if (!selfp->gc)
        {
	  selfp->gc = gdk_gc_new(widget->window);
	  gdk_gc_copy(selfp->gc, widget->style->white_gc);
	  gdk_gc_set_exposures(selfp->gc, TRUE);
	}

      selfp->current_x0 = (int)x0;
#if 0
      printf("view changed current_x0 dx y0 dy= %d %d %d %d\n",
             selfp->current_x0, dx,
             selfp->current_y0, dy
             );
#endif
      selfp->current_y0 = (int)y0;

      /* Scroll visible region */
      gdk_draw_drawable (widget->window,
                         selfp->gc,
                         widget->window,
                         src_x, src_y,
                         dst_x, dst_y,
                         GTK_WIDGET(self)->allocation.width - abs (dx),
                         GTK_WIDGET(self)->allocation.height - abs (dy));

      DBG2(g_print("Filling in: dx dy = %d %d\n", dx, dy));
      /* And fill in the new areas */
      if (dx)
	{
	    expose_rect.x = (dx < 0) ? 0 : GTK_WIDGET(self)->allocation.width - dx;
	    expose_rect.y = 0;
	    expose_rect.width = abs(dx);
	    expose_rect.height = GTK_WIDGET(self)->allocation.height;

	    gdk_window_invalidate_rect(widget->window,
				       &expose_rect,
				       FALSE);
	    gdk_window_process_updates(widget->window,
				       FALSE);

	}
      if (dy)
	{
	    expose_rect.x = 0;
	    expose_rect.y = (dy < 0) ? 0 : GTK_WIDGET(self)->allocation.height - dy;;
	    expose_rect.width = GTK_WIDGET(self)->allocation.width;
	    expose_rect.height = abs(dy);

	    gdk_window_invalidate_rect(widget->window,
				       &expose_rect,
				       FALSE);
	    gdk_window_process_updates(widget->window,
				       FALSE);

	}
    }
  
  else if (widget->window &&
	   (do_force
      || scale_x != selfp->current_scale_x
      || scale_y != selfp->current_scale_y
      || x0 != selfp->current_x0
      || y0 != selfp->current_y0))
    {
      /* Remember the current transform */
      selfp->current_scale_x = scale_x;
      selfp->current_scale_y = scale_y;
      selfp->current_x0 = (gint)x0;
      selfp->current_y0 = (gint)y0;

      expose_rect.x = 0;
      expose_rect.y = 0;
      expose_rect.width = GTK_WIDGET(self)->allocation.width;
      expose_rect.height = GTK_WIDGET(self)->allocation.height;

      /* gdk_window_ref (expose_event.window); */
      gdk_window_invalidate_rect(widget->window,
				 &expose_rect,
				 TRUE);
      gdk_window_process_updates(widget->window,
				 TRUE
				 );
    }

  return 1;
}

/*======================================================================
//  Zoom related functions.
//----------------------------------------------------------------------*/
static gint
zoom_reset(GtkImageViewer *self)
{
    view_changed(self, TRUE, 1, 1, 0, 0);
    return 1;
}

static gint
zoom_in(GtkImageViewer *self, int x, int y, double factor)
{
  double zoom_factor[2];
  int zoom_idx;
  if (factor < 0)
      factor = 1.1;

  zoom_factor[0] = selfp->current_scale_x;
  zoom_factor[1] = selfp->current_scale_y;

  for (zoom_idx = 0; zoom_idx < 2; zoom_idx++)
    {
      double z = zoom_factor[zoom_idx];  /* A shortcut */
      if (selfp->do_linear_zoom_steps) {
	if (z < 0.5)
	  z = 1.0 / (1.0/z-1);
	else
	  z = z+1;
      }
      else 
	z *= factor;
      zoom_factor[zoom_idx] = z;
    }

  if (x<0)
      x = selfp->canvas_width/2;
  if (y<0)
      y = selfp->canvas_height/2;
      
  gtk_image_viewer_zoom_around_fixed_point(self,
					   zoom_factor[0],
					   zoom_factor[1],
                                           x, y,
					   selfp->canvas_width/2,
					   selfp->canvas_height/2);

  return 1;
}

static gint
zoom_out(GtkImageViewer *self, int x, int y, double factor)
{
  double zoom_factor[2];
  int zoom_idx;

  if (factor<0)
      factor = 1.1; 

  zoom_factor[0] = selfp->current_scale_x;
  zoom_factor[1] = selfp->current_scale_y;

  for (zoom_idx = 0; zoom_idx < 2; zoom_idx++)
    {
      double z = zoom_factor[zoom_idx];  /* A shortcut */
      if (selfp->do_linear_zoom_steps) {
	if (z <= 1.0)
	  z = 1.0 / (1.0/z+1);
	else
	  z = z-1;
      }
      else 
	z /= factor;
      zoom_factor[zoom_idx] = z;
    }

  gtk_image_viewer_zoom_around_fixed_point(self,
					   zoom_factor[0],
					   zoom_factor[1],
					   selfp->canvas_width/2,
					   selfp->canvas_height/2,
					   selfp->canvas_width/2,
					   selfp->canvas_height/2);
  return 1;
}

static gint
zoom_translate(GtkImageViewer *self, int dx, int dy)
{
  view_changed(self,
	       FALSE,
	       selfp->current_scale_x,
	       selfp->current_scale_y,
	       selfp->current_x0+dx,
	       selfp->current_y0+dy);
  return 1;
}


static void
hadjustment_value_changed (GtkAdjustment *hadjustment,
                           gpointer       data)
{
  GtkImageViewer *self;
  double min = 0;
  double new_x0, dx;
  double width;

  g_return_if_fail (GTK_IS_ADJUSTMENT (hadjustment));
  g_return_if_fail (GTK_IS_IMAGE_VIEWER (data));

  self = GTK_IMAGE_VIEWER (data);

  width = selfp->scroll_width;
  min = selfp->scroll_min_x;

  // if flip then flip back to calculate same x0 as before flip!
  double v = hadjustment->value;
  double s = selfp->current_scale_x;
  if (selfp->do_flip_horizontal)
    v = 1.0 - hadjustment->page_size - v;
  new_x0 = (v * (width-selfp->hadjustment->page_size) + min) * s;
  dx = new_x0 - selfp->current_x0;

  DBG(printf("hadjustment_value_changed: dx = %d\n", (int)dx));
  if ((int)dx!=0) {
    zoom_translate(self, (int)dx, 0);
  }
    
}

static void
vadjustment_value_changed (GtkAdjustment *vadjustment,
                           gpointer       data)
{
  GtkImageViewer *self;
  double min = 0;
  double new_y0, dy;
  double height;

  g_return_if_fail (GTK_IS_ADJUSTMENT (vadjustment));
  g_return_if_fail (GTK_IS_IMAGE_VIEWER (data));

  self = GTK_IMAGE_VIEWER (data);

  height = selfp->scroll_height;
  min = selfp->scroll_min_y;

  // if flip then flip back to calculate same x0 as before flip!
  double v = vadjustment->value;
  double s = selfp->current_scale_y;
  if (selfp->do_flip_vertical)
      v = 1.0 - vadjustment->page_size - v;
  new_y0 = (v * (height-selfp->vadjustment->page_size) + min) * s;
  dy = new_y0 - selfp->current_y0;

  if ((int)dy!=0) {
#if 0
    printf("vadjustment: value dy = %f %d\n", vadjustment->value, (int)dy);
#endif
    zoom_translate(self, 0, (int)dy);
  }
}

// This function should update the adjustment so that they reflect
// the scrolling of the widget as it was decided somewhere else.
static gboolean update_adjustments(GtkImageViewer *self)
{
  double min_x = 0, min_y = 0;
  double width, height;

  if (!selfp->hadjustment
      || !selfp->vadjustment
      )
    return 0;

  width = selfp->scroll_width;
  height = selfp->scroll_height;
  min_x = selfp->scroll_min_x;
  min_y = selfp->scroll_min_y;

  if (selfp->hadjustment)
    {
      selfp->hadjustment->lower = 0;
      selfp->hadjustment->upper = 1.0;
      selfp->hadjustment->step_increment = 0.01;
      selfp->hadjustment->page_size = selfp->canvas_width / (selfp->scroll_width * selfp->current_scale_x);
      
      double v = (selfp->current_x0/selfp->current_scale_x - selfp->scroll_min_x)
        /(selfp->scroll_width-selfp->hadjustment->page_size);
      if (selfp->do_flip_horizontal)
        selfp->hadjustment->value = 1.0 - selfp->hadjustment->page_size -v;
      else
        selfp-> hadjustment->value = v;

      DBG(printf("current_x0 scale ps val = %d %f %f %f\n",
             selfp->current_x0,
             selfp->current_scale_x,
             selfp->hadjustment->page_size,
                 selfp->hadjustment->value));

      gtk_adjustment_changed(selfp->hadjustment);
      gtk_adjustment_value_changed(selfp->hadjustment);

    }

  if (selfp->vadjustment)
    {
      selfp->vadjustment->lower = 0;
      selfp->vadjustment->upper = 1.0;
      selfp->vadjustment->step_increment = 0.01;
      selfp->vadjustment->page_size = selfp->canvas_height / (selfp->scroll_height * selfp->current_scale_y);

      double v = (selfp->current_y0/selfp->current_scale_y - selfp->scroll_min_y)
        /(selfp->scroll_height-selfp->vadjustment->page_size);
      if (selfp->do_flip_vertical)
        selfp->vadjustment->value = 1.0 - selfp->vadjustment->page_size -v;
      else
        selfp->vadjustment->value = v;

      if(0)printf("current_y0 scale ps val = %d %f %f %f\n",
             selfp->current_y0,
             selfp->current_scale_y,
             selfp->vadjustment->page_size,
             selfp->vadjustment->value);

      gtk_adjustment_changed(selfp->vadjustment);
      gtk_adjustment_value_changed(selfp->vadjustment);
    }
  return 0;
}

#if 0
  property OBJECT vadjustment
    (nick = "Vertical adjustment",
     blurb = "Vertical adjustment")
        set { selfp->vadjustment = GTK_ADJUSTMENT(g_value_dup_object (VAL)); }
        get { g_value_set_object (VAL, selfp->vadjustment); }
    ;
  property OBJECT hadjustment
    (nick = "Horizontal adjustment",
     blurb = "Horizontal adjustment")
        set { selfp->hadjustment = GTK_ADJUSTMENT(g_value_dup_object (VAL)); }
        get { g_value_set_object (VAL, selfp->hadjustment); }
    ;

#endif


#line 2900 "gtk-image-viewer.cc"
