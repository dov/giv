//======================================================================
//  giv_window.gob - 
//
//  Dov Grobgeld <dov.grobgeld@gmail.com>
//  Thu Aug 16 20:12:48 2007
//----------------------------------------------------------------------

requires 2.0.0

%headertop{
#include <math.h>
#include <gtk/gtk.h>
#include "giv-data.h"
#include "plis/plis.h"
#include "givimage.h"
#include "glib-jsonrpc/glib-jsonrpc-server.h"
#include "glib-jsonrpc/glib-jsonrpc-client.h"
%}

%{
#ifdef _WIN32
#include <windows.h>
#include <cairo-win32.h>
#endif

#include <gdk/gdkkeysyms.h>
#include "givplugin.h"
#include "giv-widget.h"
#include "giv-color-map.h"
#include <stdlib.h>
#include <vector>
#include "../config.h"
#include "gtkimageviewer/gtk-image-viewer.h"
#include "logo_150_inline.i"
#include "giv-logo.i"
#include "giv-parser.h"
#include "GivPainterAgg.h"
#include "GivPainterCairoPixbuf.h"
#include "GivRenderer.h"
#include "colormaps.h"
#include "giv-info.h"
#include "giv-markup.h"
#include "cairo-svg.h"
#include "cairo-ps.h"
#include "cairo-pdf.h"
#include "GivStringArray.h"
#include "time.h"
#include <sys/stat.h>
#include "giv-calibrate-dialog.h"
#include "giv-settings.h"
#include "giv-settings-editor.h"
#include "glib-jsonrpc/glib-jsonrpc-json.h"

using namespace std;
using namespace plis;

#define CASE(s) if (strcmp(s,S_)==0)
#ifdef WIN32
#include <windows.h>
#undef PRINT_BY_IMAGE
#endif

#define MY_PI 3.141592653589793

static const char ui_descr_menu_string[] =
#include "menu-top-xml.i"
;
static const char ui_descr_popup_string[] =
#include "menu-popup-xml.i"
;
static const char copyright_string[] =
#include "copyright.i"
;

enum {
    PSEUDO_COLOR_OFF,
    PSEUDO_COLOR_LOW_CONTRAST,
    PSEUDO_COLOR_RAINBOW,
    PSEUDO_COLOR_RED_TEMP,
    PSEUDO_COLOR_BGRY,
    PSEUDO_COLOR_BLUE_WHITE,
    PSEUDO_COLOR_GRBW,
    PSEUDO_COLOR_INVERT,
    PSEUDO_COLOR_EQUALIZE,
    PSEUDO_COLOR_NORMALIZE
};
    
enum
{
    DND_TEXT_PLAIN,
    DND_TEXT_URI_LIST
};

enum
{
  MEASURE_TYPE_DIAGONAL,
  MEASURE_TYPE_HORIZONTAL,
  MEASURE_TYPE_VERTICAL
};
  
const int GIV_DEFAULT_PORT = 8222;

/* Target types for dropping into the file list */
static const GtkTargetEntry file_list_dest_targets[] = {
    { (gchar*)"text/uri-list", 0, DND_TEXT_URI_LIST }
};

static void cb_view_menu_bar (GtkAction *action, gpointer data);
static void cb_view_marks (GtkAction *action, gpointer data);
static void cb_view_balloons (GtkAction *action, gpointer data);
static void cb_view_sub_pixel (GtkAction *action, gpointer data);
static void cb_view_hflip (GtkAction *action, gpointer data);
static void cb_view_vflip (GtkAction *action, gpointer data);
static void cb_view_vertical_zoom_lock (GtkAction *action, gpointer data);
static void cb_view_colormap (GtkAction *action, gpointer data);
static void cb_view_pixel_grid (GtkAction *action, gpointer data);
static void cb_view_auto_resize (GtkAction *action, gpointer data);
static void cb_view_auto_contrast (GtkAction *action, gpointer data);
static void cb_view_auto_reload (GtkAction *action, gpointer data);
static void cb_menu_measure_distance_diagonal (GtkAction *action, gpointer data);
static void cb_menu_measure_distance_horizontal (GtkAction *action, gpointer data);
static void cb_menu_measure_distance_vertical (GtkAction *action, gpointer data);
static void cb_menu_calibrate (GtkAction *action, gpointer data);
static void cb_menu_quiver_zoom (GtkAction *action, gpointer data);
static void cb_menu_count_marks (GtkAction *action, gpointer data);
#if 0
static void cb_menu_default (GtkAction *action, gpointer data);
#endif
static void cb_menu_preferences (GtkAction *action, gpointer data);
static void cb_menu_new_window (GtkAction *action, gpointer data);
static void cb_menu_fill (GtkAction *action, gpointer data);
static void cb_menu_shrink_wrap (GtkAction *action, gpointer data);
static void cb_menu_close_window (GtkAction *action, gpointer data);
static void cb_menu_clear (GtkAction *action, gpointer data);
static void cb_menu_copyright (GtkAction *action, gpointer data);
static void cb_menu_about (GtkAction *action, gpointer data);
static void cb_menu_manual (GtkAction *action, gpointer data);
static void cb_menu_open (GtkAction *action, gpointer data);
static void cb_menu_export (GtkAction *action, gpointer data);
static void cb_menu_print (GtkAction *action, gpointer data);
static void cb_menu_mark_browser (GtkAction *action, gpointer data);
static void cb_menu_contrast_view (GtkAction *action, gpointer data);
static void cb_menu_info_dialog (GtkAction *action, gpointer data);
static gboolean giv_check_img_for_mono(GivImage *im);
static void cb_change_pseudo_color(GtkRadioAction* action,
                                   GtkRadioAction*,
                                   GivWin *self);
static void cb_image_reference(GtkWidget *widget,
                               const char *filename,
                               gpointer user_data);
static void menu_add_widget (GtkUIManager *ui, GtkWidget *widget, GtkContainer *container);
static void
cb_balloon_changed(GtkWidget *widget,
                   bool show_balloon,
                   gpointer data);
static void
cb_marks_changed(GtkWidget *widget,
                 bool show_balloon,
                 gpointer data);

static void
cb_file_list_drag_data_received (GtkWidget          *widget,
				 GdkDragContext     *context,
				 gint                x,
				 gint                y,
				 GtkSelectionData   *selection_data,
				 guint               info,
				 guint               drag_time,
				 gpointer            data);

static void
fit_marks_in_window(GivWin *self);

static void
app_error (GivWin *self,
           const char *format, ...);

static int
cb_image_size_alloc(GtkWidget *widget,
                    GtkAllocation *allocation,
                    gpointer           user_data);

static void
cb_flip_changed(GtkImageViewer *imgv,
                gboolean do_flip_horizontal,
                gboolean do_flip_vertical,
                gpointer data);
 
static void
cb_vertical_zoom_lock_changed(GtkImageViewer *imgv,
                              gboolean do_vertical_zoom_lock,
                              gpointer data);
 
static gint
cb_button_press_event (GtkWidget * widget,
                       GdkEventButton * event,
                       gpointer user_data);
static gint
cb_button_release_event (GtkWidget * widget,
                         GdkEventButton * event,
                         gpointer user_data);
static gint
cb_key_press_event (GtkWidget * widget,
                    GdkEventKey * event,
                    gpointer user_data);
static gint
cb_motion_event(GtkWidget *widget,
                GdkEventMotion *event,
                gpointer user_data);

static void
apply_color_map(GivWin *self);

static double sqr(double x);
#if 0
static void
draw_measure_line(giv_backstore_t *backstore,
                  GtkWidget *image_viewer,
                  double x0, double y0,
                  double x1, double y1);

static giv_backstore_t *create_backstore(GtkWidget *image_viewer);
#endif

static void pixbuf_to_cairo(GdkPixbuf *img,
                            // output
                            GdkPixbuf **cairo_img);
static gchar *read_pnm_comment(const char *filename);

void draw_to_cairo(cairo_t *cr,
                   int width,
                   int height,
                   GivWin *self);
bool is_file_ext(const char *fn,
                 const char* ext_match);
static gboolean cb_load_image_when_idle(gpointer user_data);
static gboolean cb_redraw_when_idle(gpointer user_data);
static void
cb_contrast_changed(GtkWidget* widget,
                    double contrast_min,
                    double contrast_max,
                    GivWin *self);

static void
export_to_file(GivWin *self,
               int width,
               int height,
               const char *filename);
static gboolean auto_reload_function(gpointer data);
static void
cb_image_annotate(GivWidget *imgv,
                  GdkPixbuf *pixbuf,
                  gint shift_x,
                  gint shift_y,
                  gdouble scale_x,
                  gdouble scale_y,
                  gpointer user_data
                  );
static void
my_lasso_draw(cairo_t *cr,
              DovtkLassoContext context,
              gpointer user_data);
static void
my_lasso_draw_rectangle(cairo_t *cr,
                        DovtkLassoContext context,
                        gpointer user_data);
static void create_remote_commands(GivWin *self);
static void giv_win_json_pick_reply(GivWin *self, const gchar *error, double x, double y);

// The following tables contain all the actions for both the menubar
// and the popup menus.
    
static int num_top_levels = 0;
 
static GtkActionEntry entries[] = 
{
  { "FileMenuAction", NULL, "_File" },                  /* name, stock id, label */
  { "ViewMenuAction", NULL, "_View" },  
  { "ToolMenuAction", NULL, "_Tools" },  
  { "HelpMenuAction", NULL, "_Help" },  
  { "ColorTableMenuAction", NULL, "_ColorTable" },  
  { "ToolMeasureAction", NULL, "_MeasureDistance" },  
    
  { "OpenAction", GTK_STOCK_OPEN,
    "_Open", "<control>O",    
    "Open",
    G_CALLBACK (cb_menu_open) },
  { "ExportAction", GTK_STOCK_SAVE,
    "_Export", "<control>E",    
    "Export",
    G_CALLBACK (cb_menu_export) },
  { "NewWindowAction", GTK_STOCK_NEW,
    "_New Window", "<control>n",    
    "New Window",
    G_CALLBACK (cb_menu_new_window) },
  { "CloseWindowAction", GTK_STOCK_CLOSE,
    "_Close Window", "<control>n",    
    "Close Window",
    G_CALLBACK (cb_menu_close_window) },
  { "ClearAction", GTK_STOCK_CLEAR,
    "_Clear", "<control>c",    
    "Clear",
    G_CALLBACK (cb_menu_clear) },
  { "PrintAction", GTK_STOCK_PRINT,
    "_Print", "<control>P",    
    "Print",
    G_CALLBACK (cb_menu_print) },
  { "QuitAction", GTK_STOCK_QUIT,
    "_Quit", "<control>Q",    
    "Quit",
    G_CALLBACK (gtk_main_quit) },
  { "AboutAction", GTK_STOCK_ABOUT,
    "_About", NULL,
    "About",
    G_CALLBACK (cb_menu_about) },
  { "ManualAction", NULL,
    "_User Manual", NULL,
    "Manual",
    G_CALLBACK (cb_menu_manual) },
  { "CopyrightAction", NULL,
    "_Copyright", NULL,
    "Copyright",
    G_CALLBACK (cb_menu_copyright) },
  { "ToolMarkBrowserAction",
    NULL,
    "View Mark Browser", NULL,    
    "View Mark Browser",
    G_CALLBACK (cb_menu_mark_browser) },
  { "ToolContrast",
    NULL,
    "Adjust Contrast", NULL,    
    "Adjust Contrast",
    G_CALLBACK (cb_menu_contrast_view) },
  { "ToolInfoAction",
    NULL,
    "View Info", NULL,    
    "View Info",
    G_CALLBACK (cb_menu_info_dialog) },
  { "PreferencesAction",
    GTK_STOCK_PREFERENCES,    
    "_Preferences", NULL,
    "Preferences",
    G_CALLBACK (cb_menu_preferences) },
  { "FillAction",
    NULL,
    "_Fill", NULL,
    "Fill",
    G_CALLBACK (cb_menu_fill) },
  { "ShrinkWrapAction",
    NULL,
    "_Shrink Wrap", NULL,
    "Shrink Wrap",
    G_CALLBACK (cb_menu_shrink_wrap) },
  { "ToolCalibrateAction",
    NULL,    
    "_Calibrate pixel size", NULL,
    "Calibrate",
    G_CALLBACK (cb_menu_calibrate) }
};

static GtkToggleActionEntry toggle_entries[] =
{
  { "ViewMenuBarAction",
    NULL,
    "View Menu", "<control>V",    
    "View Menu",
    G_CALLBACK (cb_view_menu_bar), TRUE },
  { "ViewMarksAction",
    NULL,
    "View Marks", NULL,    
    "View Marks",
    G_CALLBACK (cb_view_marks), TRUE },
  { "ViewBalloonAction",
    NULL,
    "View Balloons", NULL,    
    "View Balloons",
    G_CALLBACK (cb_view_balloons), FALSE },
  { "ViewSubPixelAction",
    NULL,
    "Sub pixel coord", NULL,    
    "View sub pixel",
    G_CALLBACK (cb_view_sub_pixel), FALSE },
  { "ViewHorizontalFlip",
    NULL,
    "Horizontal Flip", NULL,    
    "Horizontal Flip",
    G_CALLBACK (cb_view_hflip), FALSE },
  { "ViewVerticalFlip",
    NULL,
    "Vertical Flip", NULL,    
    "Vertical Flip",
    G_CALLBACK (cb_view_vflip), FALSE },
  { "ViewVerticalZoomLock",
    NULL,
    "Vertical Zoom Lock", NULL,    
    "Vertical Zoom Lock",
    G_CALLBACK (cb_view_vertical_zoom_lock), FALSE },
  { "ViewColorMap",
    NULL,
    "Colormap Bar", NULL,    
    "Colormap Bar",
    G_CALLBACK (cb_view_colormap), FALSE },
  { "ViewPixelGrid",
    NULL,
    "View Pixel Grid", NULL,    
    "View Pixel Grid",
    G_CALLBACK (cb_view_pixel_grid), FALSE },
  { "AutoResize",
    NULL,
    "_Auto Resize", NULL,    
    "Auto Resize",
    G_CALLBACK (cb_view_auto_resize), TRUE },
  { "AutoContrast",
    NULL,
    "_Auto Contrast", NULL,    
    "Auto Resize",
    G_CALLBACK (cb_view_auto_contrast), TRUE },
  { "AutoReload",
    NULL,
    "A_uto Reload", NULL,    
    "Auto Reload the image",
    G_CALLBACK (cb_view_auto_reload), FALSE },
  { "ToolMeasureDistanceDiagonalAction",
    NULL,    
    "_Measure Distance Diagonal", NULL,
    "Measure Distance Diagonal",
    G_CALLBACK (cb_menu_measure_distance_diagonal), FALSE },
  { "ToolMeasureDistanceHorizontalAction",
    NULL,    
    "_Measure Distance Horizontal", NULL,
    "Measure Distance Horizontal",
    G_CALLBACK (cb_menu_measure_distance_horizontal), FALSE },
  { "ToolMeasureDistanceVerticalAction",
    NULL,    
    "_Measure Distance Vertical", NULL,
    "Measure Distance Vertical",
    G_CALLBACK (cb_menu_measure_distance_vertical), FALSE },
  { "ToolQuiverZoomAction",
    NULL,    
    "_Quiver Zoom", NULL,
    "Quiver Zoom",
    G_CALLBACK (cb_menu_quiver_zoom), FALSE },
  { "ToolCountMarks",
    NULL,    
    "_Count Marks", NULL,
    "Count Marks",
    G_CALLBACK (cb_menu_count_marks), FALSE },
};

static GtkRadioActionEntry actionsPseudoColor[] = {
    { "PseudoColorNone", NULL, "_None", NULL, "Histogram equaliziation", PSEUDO_COLOR_OFF },
    { "PseudoColorEqualize", NULL, "_Equalize", NULL, NULL, PSEUDO_COLOR_EQUALIZE },
    { "PseudoColorNormalize", NULL, "N_ormalize", NULL, NULL, PSEUDO_COLOR_NORMALIZE },
    { "PseudoColorInvert", NULL, "_Invert", NULL, NULL, PSEUDO_COLOR_INVERT },
    { "PseudoColorLowContrast", NULL, "Low _Contrast", NULL, NULL, PSEUDO_COLOR_LOW_CONTRAST },
    { "PseudoColorRainbow", NULL, "_Rainbow", NULL, NULL, PSEUDO_COLOR_RAINBOW },
    { "PseudoColorRedTemp", NULL, "Red _Temperature", NULL, NULL, PSEUDO_COLOR_RED_TEMP },
    { "PseudoColorBGRY", NULL, "_Blue Green Red Yellow", NULL, NULL, PSEUDO_COLOR_BGRY },
    { "PseudoColorBlueWhite", NULL, "Blue _White", NULL, NULL, PSEUDO_COLOR_BLUE_WHITE },
    { "PseudoColorGRBW", NULL, "_Green Red Blue White", NULL, NULL, PSEUDO_COLOR_GRBW }
};
    
static void die(const char *fmt, ...);

static gchar *last_image_path = NULL;
static gchar *last_export_image_path = NULL;

%}

%privateheader{
#include "giv-mark-tree-dialog.h"
#include "giv-contrast.h"
#include "giv-settings.h"
#include "dovtk-lasso.h"
%}

class Giv:Win from Gtk:Window
{
    private GtkWidget *w_menubox;
    private GtkWidget *w_popup;
    private GtkWidget *w_imgv;
    private GtkWidget *w_info_label;
    private GtkWidget *w_filechooser = NULL;
    private GtkWidget *w_mark_tree_dialog = NULL;
    private GtkWidget *w_contrast_view = NULL;
    private GtkWidget *w_calibrate = NULL;
    private GtkWidget *w_info_dialog = NULL;
    private GtkWidget *w_balloon_window = NULL;
    private GtkWidget *w_balloon_label = NULL;
    private GtkWidget *w_scrolled_win;
    private GtkWidget *w_preferences = NULL;
    private GivImage *img_org = NULL
        destroy {
        if (img_org) {
            giv_image_unref(img_org);
            img_org = NULL;
        }
    };
    private double contrast_min = 0;
    private double contrast_max = 255;
    private gchar *format = NULL destroy { g_free(format); };
    private GdkPixbuf *img_display = NULL
        destroy {
            if (img_display) 
              g_object_unref(img_display);
        };
        
    // This image is a copy of the img display but with label
    // colors. It is never shown onto the screen.
    private GdkPixbuf *w_label_image = NULL
        destroy {
            if (w_label_image) {
                g_object_unref(w_label_image);
            };
        };
    private gint cb_annotate_id;
    private bool do_view_marks = true;
    private bool do_view_colormap = false;
    private bool img_is_mono = false;
    private bool do_show_sub_pixel = false;
    private bool do_square_aspect_ratio = true;
    private bool do_auto_fit_marks = TRUE;
    private bool do_auto_reload = FALSE;
    private bool do_draw_pixel_grid = TRUE;
    // If the image is triggered to be loaded by auto reload then the
    // a failure to load is silently ignored. This is handled by the
    // auto_relod_trigger flag;
    private bool auto_reload_trigger = FALSE; 
    private bool do_auto_contrast = TRUE;
    private bool do_no_transparency = FALSE;
    private gdouble last_move_x=-1;
    private gdouble last_move_y=-1;
    private double last_cx;
    private double last_cy;
    private GtkUIManager *menu_manager = NULL;
    private GtkUIManager *popup_manager = NULL;
    private gint colormap = PSEUDO_COLOR_OFF;
    private GPtrArray *filename_list = NULL
        destroy {
            g_ptr_array_foreach(filename_list, (GFunc)giv_string_array_free, NULL);
        };
                                     
    private int filename_list_index = -1;
    private int img_in_list_idx = -1;
    private GPtrArray *cb_names = NULL
        destroy {
            giv_string_array_free(cb_names);
        };
    //   private giv_backstore_t *back_store = NULL;
    private DovtkLasso *lasso = NULL;
    private gboolean is_measuring_distance = FALSE;
    private gint measure_type = 0;
    private gboolean is_counting_marks = FALSE;
    private int picking_mode = 0;
    private gboolean is_quiver_zoom = FALSE;
    private gint measure_point_index = 0;
    private double picking_x=-1;
    private double picking_y=-1;
    private double measure_x1=-1;
    private double measure_y1=-1;
    private double measure_x2=-1;
    private double measure_y2=-1;
    private double quiver_scale = 1.0;
    private GdkCursor *current_cursor=0;
    private GdkCursor *cursor_plus=0;
    private GdkCursor *cursor_diamond_cross = NULL;
    private GdkCursor *cursor_default=0;
    private GtkWidget *w_color_map_bar = NULL;
    private gboolean is_dragging = FALSE;
    private GtkPrintSettings *print_settings = NULL;
    private gchar *img_comment = NULL;
    private gint idle_index = 0;
    private gint idle_handle = -1;
    private time_t cached_mtime = 0;
    private gint current_slice = 0;
    private double pixelsize =  1;
    private gchar *pixelsize_unit = NULL;
    private double last_measure_distance_in_pixels = -1;
    private GivSettings *giv_settings = NULL destroy { g_object_unref(giv_settings); };
    private GLibJsonRpcServer *jsonrpc_server;
    private GLibJsonRpcAsyncQuery *json_query = NULL;
    private gboolean do_pick_coordinate = FALSE;
    private gboolean do_fit_on_load_image = FALSE;
    private gdouble margin = 10;
    private GtkActionGroup *toggle_actions = nullptr;
    private gboolean in_menu_measure = FALSE;
    private gchar *last_measure_text = NULL;

    public GtkWidget *
    new (int argc, char *argv[])
    {
        GivWin *self = GIV_WIN(GET_NEW); 
        GtkWidget *w_vbox, *w_right_box;
        GtkActionGroup *action_group;
        GError *error = NULL;
        int argp = 1;
        GdkPixbuf *pixbuf_icon;
        bool do_join = false;
        int width = 500;
        int height = 500;
        double scale = -1;
        double shift_x = 0;
        double shift_y = 0;
        char *export_filename = NULL;
        int giv_port = GIV_DEFAULT_PORT;
        gboolean do_remote = FALSE;
        const gchar *giv_host = "localhost"; // Currently fixed
        gchar *remote_string=NULL;
        gchar *json_method=NULL;
        gchar *json_params_string=NULL;

        // Parse command line
        while(argp < argc && argv[argp][0] == '-') {
            char *S_ = argv[argp++];

            CASE("-help") {
                printf("giv - An image and vector viewer\n"
                       "\n"
                       "Syntax:\n"
                       "    giv [-n] [-join] image [image...]\n"
                       "\n"
                       "Options:\n" 
                       "    -join      Join the display of all files on command line\n"
                       "    -n         Initially use 1:1 zoom for images.\n"
                       "    -geometry  Set size of image viewer\n"
                       "    -zoom scale shift_x shift_y   Zoom the image\n"
                       "    -export fn                    Export to fn.\n"
                       "    -port p    Set port for giv remote jsonrpc server. Default is 8222\n"
                       "    -remote cmd   Run giv remote command cmd. Use \"-remote\n"
                       "                  help\" to get a list of supported commands.\n"

                       );
                exit(0);
            }
            CASE("-n") {
                selfp->do_auto_fit_marks = false;
                continue;
            }
            CASE("-join") {
                do_join = true;
                continue;
            }
            CASE("-geometry") {
                llip matches;
                if (slip(argv[argp++]).m("(\\d+)x(\\d+)", matches)) {
                    width = atoi(matches[1]);
                    height = atoi(matches[2]);
                }
                continue;
            }
            CASE("-zoom") {
                scale = atof(argv[argp++]);
                shift_x = atof(argv[argp++]);
                shift_y = atof(argv[argp++]);
                continue;
            }
            CASE("-export")
              {
                export_filename = argv[argp++];
                continue;
              }
            CASE("-port")
              {
                giv_port = atoi(argv[argp++]);
                continue;
              }
            CASE("-remote")
              {
                do_remote = TRUE;
                remote_string= argv[argp++];
                continue;
              }
            CASE("-json_method")
              {
                do_remote = TRUE;
                json_method = g_strdup(argv[argp++]);
                continue;
              }
            CASE("-json_params")
              {
                json_params_string = argv[argp++];
                continue;
              }

            printf("Unknown option %s!\n", S_);
            exit(-1);
        }

        // Load an image into a remote instance of giv. If this fails,
        // then normal loading should take place.
        if (do_remote)
          {
            GLibJsonRpcClient *client = glib_jsonrpc_client_new(giv_host,
                                                                giv_port);

            if (client)
              {
                JsonNode *params = NULL;
                if (!json_method)
                  {
                    // Either split remote string as space separated by params
                    char **json_args = g_strsplit(remote_string," ",-1);
                    json_method = g_strdup(json_args[0]);
                    char **json_params = &json_args[1];
                    params = glib_jsonrpc_json_strv_to_json_array(json_params);
                    g_strfreev(json_args);
                  }
                else if (json_params_string)
                  params = glib_jsonrpc_json_string_to_json_node(json_params_string);

                JsonNode *response = NULL;
                glib_jsonrpc_client_call(client,
                                         json_method,
                                         params,
                                         // output
                                         &response);
                g_free(json_method);
                json_node_free(params);
                if (response)
                  {
                    gchar *str = glib_jsonrpc_json_to_string(response);
                    printf("%s\n",str);
                    g_free(str);
                    json_node_free(response);
                  }
                exit(0);
              }

            // Fail!
            fprintf(stderr, "No giv remote client found!\n");
            exit(-1);
          }
            
        selfp->cursor_plus = gdk_cursor_new(GDK_PLUS);
        selfp->cb_names = g_ptr_array_new();
        selfp->filename_list = g_ptr_array_new();
        selfp->pixelsize_unit = g_strdup("");

        selfp->jsonrpc_server = glib_jsonrpc_server_new(giv_port);

        // Silently ignore failed server
        if (selfp->jsonrpc_server) 
            create_remote_commands(self);

        gchar *settings_file = g_strdup_printf("%s/.config/Giv/giv.conf", g_get_home_dir());
        selfp->giv_settings = GIV_SETTINGS(giv_settings_new(settings_file));

        gtk_window_set_resizable(GTK_WINDOW(self), true);

        pixbuf_icon = gdk_pixbuf_new_from_inline(sizeof(image_giv_icon_inline),
                                                 image_giv_icon_inline,
                                                 FALSE,
                                                 &error);
        
        gtk_window_set_icon (GTK_WINDOW(self),
                             pixbuf_icon);
        g_object_unref(pixbuf_icon);

        num_top_levels++;
        g_signal_connect (G_OBJECT(self), "destroy",
                          G_CALLBACK (giv_win_destroy), self);
    
    
        w_vbox = gtk_vbox_new(0,0);
        gtk_widget_show(w_vbox);
        gtk_container_add(GTK_CONTAINER(self),
                          w_vbox);
    
        selfp->w_menubox = gtk_vbox_new(0,0);
        gtk_widget_show(selfp->w_menubox);
        w_right_box = gtk_hbox_new(0,0);
        gtk_widget_show(w_right_box);
    
        action_group = gtk_action_group_new ("TestActions");
        selfp->toggle_actions = action_group;
        selfp->menu_manager = gtk_ui_manager_new ();
        selfp->popup_manager = gtk_ui_manager_new ();
        gtk_ui_manager_insert_action_group (selfp->menu_manager, action_group, 0);
        gtk_ui_manager_insert_action_group (selfp->popup_manager, action_group, 0);
        gtk_action_group_add_actions (action_group, entries, G_N_ELEMENTS(entries), self);
        gtk_action_group_add_toggle_actions (action_group,
                                             toggle_entries,
                                             G_N_ELEMENTS(toggle_entries),
                                             self);
        gtk_action_group_add_radio_actions (action_group,
                                            actionsPseudoColor,
                                            G_N_ELEMENTS(actionsPseudoColor),
                                            0,
                                            G_CALLBACK(cb_change_pseudo_color),
                                            self);
    
        gtk_ui_manager_add_ui_from_string (selfp->menu_manager,
                                           ui_descr_menu_string,
                                           -1,
                                           &error);
        if (error)
            die("Got error: %s\n", error->message);
        gtk_ui_manager_add_ui_from_string (selfp->popup_manager,
                                           ui_descr_popup_string,
                                           -1,
                                           &error);
        if (error)
            die("Got error: %s\n", error->message);
        selfp->w_popup = gtk_ui_manager_get_widget (selfp->popup_manager,
                                                    "/popup");
        /* This signal is necessary in order to place widgets from the UI manager
         * into the menu_box */
        g_signal_connect(selfp->menu_manager, 
                         "add_widget", 
                         G_CALLBACK (menu_add_widget), 
                         selfp->w_menubox
                         );
        g_signal_connect(selfp->popup_manager, 
                         "add_widget", 
                         G_CALLBACK (menu_add_widget), 
                         selfp->w_popup
                         );
        gtk_box_pack_start(GTK_BOX(w_vbox),
                           selfp->w_menubox, FALSE, FALSE, 0);
        gtk_widget_show(gtk_ui_manager_get_widget(selfp->menu_manager,
                                                  "/menubar"));


        GtkWidget *w_hbox = gtk_hbox_new(FALSE, 0);
        gtk_widget_show(w_hbox);
        gtk_box_pack_start(GTK_BOX(w_vbox),
                           w_hbox, TRUE, TRUE, 0);
        
        selfp->w_color_map_bar = GTK_WIDGET(giv_color_map_new());
        gtk_box_pack_start(GTK_BOX(w_hbox),
                           selfp->w_color_map_bar, FALSE, FALSE, 0);

        selfp->w_scrolled_win = gtk_scrolled_window_new(NULL, NULL);
        gtk_widget_show(selfp->w_scrolled_win);
        gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(selfp->w_scrolled_win),
                                       GTK_POLICY_AUTOMATIC,
                                       GTK_POLICY_AUTOMATIC);
        
        
        gtk_box_pack_start(GTK_BOX(w_hbox),
                           selfp->w_scrolled_win, TRUE, TRUE, 0);

        selfp->w_imgv = giv_widget_new(NULL);
        gtk_image_viewer_set_fill_on_resize_margin(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                                   selfp->margin);

        gtk_widget_show(selfp->w_imgv);
        g_signal_connect(selfp->w_imgv, "file-reference",
                         G_CALLBACK(cb_image_reference), self);
        g_signal_connect(selfp->w_imgv, "button-press-event",
                         G_CALLBACK(cb_button_press_event), self);
        g_signal_connect(selfp->w_imgv, "button-release-event",
                         G_CALLBACK(cb_button_release_event), self);
        g_signal_connect(selfp->w_imgv, "key-press-event",
                         G_CALLBACK(cb_key_press_event), self);
        g_signal_connect(selfp->w_imgv, "motion-notify-event",
                         G_CALLBACK(cb_motion_event), self);
        g_signal_connect(selfp->w_imgv,
                         "balloon-changed",
                         G_CALLBACK(cb_balloon_changed),
                         self);
        g_signal_connect(selfp->w_imgv,
                         "show-marks-changed",
                         G_CALLBACK(cb_marks_changed),
                         self);

        // Scrolling is like moving
        g_signal_connect(selfp->w_imgv, "scroll-event",
                         G_CALLBACK(cb_motion_event), self);
#if 0
        giv_widget_set_file_reference_callback(GIV_WIDGET(selfp->w_imgv),
                                               cb_image_reference, self);
#endif

        gtk_container_add(GTK_CONTAINER(selfp->w_scrolled_win),
                          selfp->w_imgv);

        // The new windows version does not propagate this as it should!
        gtk_image_viewer_set_vadjustment(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                         gtk_scrolled_window_get_vadjustment(
                                             GTK_SCROLLED_WINDOW(selfp->w_scrolled_win)));
        gtk_image_viewer_set_hadjustment(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                         gtk_scrolled_window_get_hadjustment(
                                             GTK_SCROLLED_WINDOW(selfp->w_scrolled_win)));

        selfp->w_info_label = gtk_label_new("");
        gtk_widget_show(selfp->w_info_label);
        gtk_box_pack_start(GTK_BOX(w_vbox),
                           selfp->w_info_label, FALSE, FALSE, 0);

        gtk_widget_set_events(GTK_WIDGET(selfp->w_imgv),
                              GDK_EXPOSURE_MASK
                              | GDK_STRUCTURE_MASK
                              | GDK_SUBSTRUCTURE_MASK
                              | GDK_PROPERTY_CHANGE_MASK
                              | GDK_POINTER_MOTION_MASK 
                              | GDK_BUTTON_PRESS_MASK
                              | GDK_KEY_PRESS_MASK
                              | GDK_LEAVE_NOTIFY_MASK
                              | GDK_SCROLL_MASK
                              );
    
        g_signal_connect(selfp->w_imgv,
                         "flip-changed",
                         G_CALLBACK(cb_flip_changed),
                         self);
        
        g_signal_connect(selfp->w_imgv,
                         "vertical-zoom-lock-changed",
                         G_CALLBACK(cb_vertical_zoom_lock_changed),
                         self);
        
        g_signal_connect (selfp->w_imgv,
                          "drag-data-received",
                          G_CALLBACK (cb_file_list_drag_data_received),
                          self);

        /* DnD */
        gtk_drag_dest_set (selfp->w_imgv,
                           (GTK_DEST_DEFAULT_ALL),
                           file_list_dest_targets,
                           G_N_ELEMENTS(file_list_dest_targets),
                           GDK_ACTION_COPY);
        
        GtkTargetList *target_list;
        target_list = gtk_target_list_new (NULL, 0);
        gtk_target_list_add_uri_targets (target_list, DND_TEXT_URI_LIST);
        gtk_target_list_add_text_targets (target_list, DND_TEXT_PLAIN);
        gtk_drag_dest_set_target_list (GTK_WIDGET (selfp->w_imgv), target_list);
        gtk_target_list_unref (target_list);

        gtk_window_set_default_size (GTK_WINDOW(self), width, height);
        gtk_widget_set_size_request(selfp->w_imgv, width, height);

#if 0
        giv_win_shrink_wrap(self);
#endif

        // This is ugly, don't show the window if we are exporting...
#if 0
        if (!export_filename)
            gtk_widget_show_all(GTK_WIDGET(self));
#endif

        // Create the balloon window that is not shown at this point
        selfp->w_balloon_window = gtk_window_new (GTK_WINDOW_POPUP);

        // Make tooltip color yellow. This should probably be configurable
        {
            GdkColor color = {0,0,0,0};
            gdk_color_parse("yellow", &color);
            gtk_widget_modify_bg(selfp->w_balloon_window,
                                 GTK_STATE_NORMAL, &color);
        }

        gtk_widget_set_app_paintable (selfp->w_balloon_window, TRUE);
        gtk_window_set_resizable (GTK_WINDOW(selfp->w_balloon_window), FALSE);
        selfp->w_balloon_label = gtk_label_new("Balloon");
        gtk_label_set_line_wrap (GTK_LABEL (selfp->w_balloon_label), TRUE);
        gtk_misc_set_alignment (GTK_MISC (selfp->w_balloon_label), 0.5, 0.5);
        gtk_widget_show (selfp->w_balloon_label);
        gtk_container_add (GTK_CONTAINER (selfp->w_balloon_window),
                           selfp->w_balloon_label);

        // Hide the colormap bar. It will be displayed if we load a
        // non 8-bit image.
        gtk_widget_hide(selfp->w_color_map_bar);

        gdk_flush();

        // Apply settings
        gtk_check_menu_item_set_active(
          GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/Sub-pixel")),
          selfp->giv_settings->default_show_subpixel);
        gtk_check_menu_item_set_active(
          GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/AutoResize")),
          selfp->giv_settings->default_auto_resize);
        gtk_check_menu_item_set_active(
          GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/AutoContrast")),
          selfp->giv_settings->default_auto_contrast);
        gtk_image_viewer_set_fill_on_resize(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                            selfp->giv_settings->default_auto_resize);

        // Handle the command line
        if (argc == argp+1) {
            char *filename = argv[argp++];
            char *basename = g_path_get_basename(filename);

            giv_win_read_dir_into_filename_list(self, filename);
            selfp->filename_list_index = -1;
            for (int i=0; i<(int)selfp->filename_list->len; i++) {
                GPtrArray *string_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list, i);
                gchar *filename0 = (gchar*)g_ptr_array_index(string_list, 0);
                char *fl_basename = g_path_get_basename(filename0);
                bool are_equal = (slip(fl_basename) == slip(basename));
                g_free(fl_basename);
                if (are_equal) {
                    selfp->filename_list_index = i;
                    break;
                }
            }
            if (selfp->filename_list->len
                && selfp->filename_list_index < 0) {
                app_error(self,
                          "Failed loading %s! No such file.\n",
                          filename);
                GPtrArray *string_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list, 0);
                gchar *filename0 = (gchar*)g_ptr_array_index(string_list, 0);
                
                giv_win_load_file(self, filename0);
                selfp->filename_list_index = 0;
            }
#if 0
            else
                giv_win_set_current_file(self,
                                         selfp->filename_list_index);
#endif
            g_free(basename);
        }
        else {
            selfp->filename_list_index = 0;
            if (do_join) {
                GPtrArray *string_list = g_ptr_array_new();
                while (argp < argc) {
                    g_ptr_array_add(string_list, g_strdup(argv[argp++]));
                }

                g_ptr_array_add(selfp->filename_list,
                                string_list);
            }
            else {
                while (argp < argc) {
                    GPtrArray *string_list = g_ptr_array_new();
                    g_ptr_array_add(string_list, g_strdup(argv[argp++]));
                    g_ptr_array_add(selfp->filename_list,
                                    string_list);
                    if (selfp->filename_list->len==1) {
#if 0
                        giv_win_set_current_file(self,
                                                    0);
#endif
                    }
                }
            }
        }

        selfp->idle_index = selfp->filename_list_index;
        selfp->do_fit_on_load_image = TRUE;
        selfp->idle_handle = g_idle_add(cb_load_image_when_idle,
                                        self);
#if 0
        giv_win_set_current_file(self,
                                 selfp->filename_list_index);
#endif
#if 0
        printf("img_org do_auto_fit_marks = %d %d\n",
               selfp->img_org, selfp->do_auto_fit_marks);
#endif

        if (scale> 0) {
            gtk_image_viewer_set_scale_and_shift(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                                 scale, scale,
                                                 shift_x, shift_y);
        }
#if 0
        else if (!selfp->img_org)
            fit_marks_in_window(self);
#endif
        else if (!selfp->do_auto_fit_marks) {
            gtk_image_viewer_zoom_reset(GTK_IMAGE_VIEWER(selfp->w_imgv));
        }

        // This is ugly. If there is an export file name then use it
        // and exit. The problem with this approach is that we are
        // still dependent on a windowing system.
        if (export_filename) {
            export_to_file(self,
                           width,
                           height,
                           export_filename);
            exit(0);
        }

        return GTK_WIDGET(self);
    }

    
    public void destroy(self)
    {
        num_top_levels--;
        gtk_widget_destroy(GTK_WIDGET(self));

        if (num_top_levels == 0)
            gtk_main_quit();
    }

    public int load_giv(self,
                        const char *filename)
    {
      //        giv_widget_clear_giv(GIV_WIDGET(selfp->w_imgv));
        giv_widget_add_giv_from_file(GIV_WIDGET(selfp->w_imgv),
                                     filename);
#if 0
        //        ((GivParser*)selfp->giv_parser)->clear();
        ((GivParser*)selfp->giv_parser)->parse_file(filename);
        selfp->quiver_scale = ((GivParser*)selfp->giv_parser)->get_quiver_scale();
#endif
        if (selfp->do_fit_on_load_image || selfp->do_auto_fit_marks) {
            fit_marks_in_window(self);
            selfp->do_fit_on_load_image = false;
        }
        
        giv_win_redraw(self);
        return 0;
    }

    public GPtrArray *get_giv_data(self)
    {
        GivParser *giv_parser = giv_widget_get_giv_parser(GIV_WIDGET(selfp->w_imgv));
        return giv_parser_get_giv_datasets(giv_parser);
    }
    
    public void load_image(self,
                           const char *filename)
    {
        GError *error = NULL;
        GivImage *new_img = NULL;

        new_img = giv_image_new_from_file(filename,
                                          &error);

        selfp->current_slice=0;

        if (selfp->img_org) {
          giv_image_unref(selfp->img_org);
          selfp->img_org = NULL;
        }

        if (slip(filename).m("p(g|p)m","i")) {
            if (selfp->img_comment)
                g_free(selfp->img_comment);
            selfp->img_comment = read_pnm_comment(filename);
        }

        selfp->auto_reload_trigger = false;
        
        selfp->img_org = new_img;

        if (!new_img)
            ; // Ignore
        else if (selfp->do_auto_contrast || new_img->one_bit)
            giv_image_get_min_max(new_img,
                                  // output
                                  &selfp->contrast_min,
                                  &selfp->contrast_max);
        else if (new_img->img_type == GIVIMAGE_U8
            || new_img->img_type == GIVIMAGE_RGB_U8
            || new_img->img_type == GIVIMAGE_RGBA_U8) {
            gtk_widget_hide(selfp->w_color_map_bar);
            selfp->do_view_colormap = FALSE;
            selfp->contrast_min = 0;
            selfp->contrast_max = 256;
        }
        else {
            gtk_widget_show(selfp->w_color_map_bar);
            selfp->do_view_colormap = TRUE;
            giv_color_map_set_min_max(GIV_COLOR_MAP(selfp->w_color_map_bar),
                                      selfp->contrast_min,
                                      selfp->contrast_max);
        }
        giv_color_map_set_min_max(GIV_COLOR_MAP(selfp->w_color_map_bar),
                                  selfp->contrast_min,
                                  selfp->contrast_max);
        gtk_check_menu_item_set_active(
            GTK_CHECK_MENU_ITEM(
                gtk_ui_manager_get_widget(selfp->menu_manager,
                                          "/menubar/ViewMenu/ColorMapBar")),
            selfp->do_view_colormap);

        if (selfp->w_contrast_view)
            giv_contrast_set_image(GIV_CONTRAST(selfp->w_contrast_view),
                                   selfp->img_org);

        // Create a formatting pattern suitable for the image aiming
        // at four significant digits. This should probably be configurable.
        double min = selfp->contrast_min;
        double max = selfp->contrast_max;

        // Create a suitable gray level formatting for the image.
        if (selfp->format)
        {
            g_free(selfp->format);
            selfp->format = NULL;
        }
        if (!new_img)
            ;
        else if (new_img->img_type <= GIVIMAGE_I32)
            selfp->format = g_strdup("%.0f");
        else if (max-min > 1e-3 && max-min <= 1e-2) 
            selfp->format = g_strdup("%.5f");
        else if (max-min > 1e-2 && max-min <= 1e-1) 
            selfp->format = g_strdup("%.4f");
        else if (max-min > 0.1 && max-min <=  1) 
            selfp->format = g_strdup("%.3f");
        else if (max-min > 1 && max-min <=  10) 
            selfp->format = g_strdup("%.2f");
        else if (max-min <= 1000) 
            selfp->format = g_strdup("%.1f");
        else
            selfp->format = g_strdup("%.4g");

        if (new_img)
            selfp->img_is_mono = giv_check_img_for_mono(selfp->img_org);

        apply_color_map(self);

        //giv_win_shrink_wrap(self);
        if (error) {
            // Silently ignore image failures on auto reload
            if (selfp->do_auto_reload && selfp->auto_reload_trigger) {
                // Force a new test
                selfp->cached_mtime = 0;
                return;
            }
            else {
                app_error(self,
                          "Failed to load image %s: %s\n",
                          filename, error->message);
            }

            g_error_free(error);

            // Run rest of image to clear the old image
        }
    }

    public void load_file(self,
                          const char *filename)
    {
        if (g_str_has_suffix(filename, ".giv")
            || g_str_has_suffix(filename, ".marks")
            )
            giv_win_load_giv(self, filename);
        else {
            //            ((GivParser*)selfp->giv_parser)->clear();
            giv_win_load_image(self, filename);
        } 
        if (selfp->w_mark_tree_dialog)
            giv_mark_tree_dialog_update_tree_view(GIV_MARK_TREE_DIALOG(selfp->w_mark_tree_dialog));

        gchar *basename = g_path_get_basename(filename);
        gchar *new_title = g_strdup_printf("giv: %s", basename);

        if (selfp->do_auto_fit_marks)
            gtk_image_viewer_zoom_fit(GTK_IMAGE_VIEWER(selfp->w_imgv));
#if 0
        gtk_window_set_title(GTK_WINDOW(self), new_title);
#endif
        g_free(new_title);
        g_free(basename);

    }

    /**
     *
     * Set the current image displayed to image_index. This function
     * clears the previous image being displayed.
     **/
    private void set_current_file(self,
                                  int display_index)
    {
        int img_in_list_idx = -1;

        giv_widget_popdown_balloon(GIV_WIDGET(selfp->w_imgv));
#if 0
        if (selfp->back_store)
            giv_backstore_invalidate(selfp->back_store);
#endif
        if (display_index < 0)
            return;

        // Erase the old marks
        giv_widget_clear_giv(GIV_WIDGET(selfp->w_imgv));
        //        printf("freezing...\n");
        gtk_image_viewer_set_freeze(GTK_IMAGE_VIEWER(selfp->w_imgv), TRUE);
#if 0
        g_signal_handler_block(selfp->w_imgv,
                               selfp->cb_annotate_id
                               );

#endif
        // Load files and check if we have an image
        gboolean has_image = false;
        giv_string_array_free(selfp->cb_names);
        selfp->cb_names = g_ptr_array_new();
        if (display_index < (int)selfp->filename_list->len) {
            GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                               display_index);
            for (int i=0; i<(int)fn_list->len; i++) {
                gchar *fn = (gchar*)g_ptr_array_index(fn_list, i);

                if (i==0) {
                    struct stat st;
                    stat(fn, &st);
                    selfp->cached_mtime = st.st_mtime;
                }

                g_ptr_array_add(selfp->cb_names, g_strdup(fn));

                if (slip(fn).m("\\.(giv|marks)")
                    || i == 0) 
                    giv_win_load_file(self, fn);
            }
        }
        for (int i=0; i<(int)selfp->cb_names->len; i++) {
            gchar *fn = (gchar *)g_ptr_array_index(selfp->cb_names, i);
            if (!slip(fn).m("\\.(giv|marks)")) {
                has_image = true;
                break;
            }
        }

        // If the new entry does not contain an image, then clear
        // the old image.
        if (!has_image) {
            if (selfp->img_org)
              {
                giv_image_unref(selfp->img_org);
                selfp->img_org = NULL;
              }
            if (selfp->img_display) {
                g_object_unref(selfp->img_display);
                selfp->img_display = NULL;
            }

            // Erase comments
            if (selfp->img_comment) {
                g_free(selfp->img_comment);
                selfp->img_comment = NULL;
            }
            gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv), NULL);
        }
        else
            img_in_list_idx = 0;

        // Load the new data
        bool found_img = false;
        for (int i=1; i<(int)selfp->cb_names->len; i++) {
            slip fn = (gchar*)g_ptr_array_index(selfp->cb_names, i);
            if (!fn.m(".giv|.marks")) {
                if (found_img)
                    continue;
                found_img = true;
                img_in_list_idx = i;
            }
            giv_win_load_file(self, fn);
        }

        selfp->filename_list_index = display_index;
        selfp->img_in_list_idx = img_in_list_idx;
        giv_win_set_image_info(self);
        
#if 0
        printf("Redrawing after thawing... auto_fit = %d\n",
               selfp->do_auto_fit_marks);
        g_signal_handler_unblock(selfp->w_imgv,
                               selfp->cb_annotate_id
                               );
#endif
        gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                   selfp->img_display);

        //        printf("unfreezing...\n");
        gtk_image_viewer_set_freeze(GTK_IMAGE_VIEWER(selfp->w_imgv), FALSE);
        if (selfp->do_auto_fit_marks) {
            fit_marks_in_window(self);
        }

    }

    public void set_image_info(self)
    {
        int fli = selfp->filename_list_index;
        if (fli >= (int)selfp->filename_list->len
            || fli < 0)
            return;

        GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                           fli);
        gchar *basename = g_path_get_basename((gchar*)g_ptr_array_index(fn_list, 0));
        gchar *new_title = NULL;        

        if (selfp->img_in_list_idx > 0
            && selfp->cb_names
            && selfp->img_in_list_idx < (int)selfp->cb_names->len
            ) {
            gchar *fn = (gchar*)g_ptr_array_index(selfp->cb_names, selfp->img_in_list_idx);
            gchar *img_basename = g_path_get_basename(fn);
            new_title = g_strdup_printf("giv: %s - %s",
                                        basename,
                                        img_basename);
            g_free(img_basename);
        }
        else 
            new_title = g_strdup_printf("giv: %s", basename);

        if (selfp->img_org &&selfp->img_org->depth>1)
            gtk_label_set_text(GTK_LABEL(selfp->w_info_label),
                               slipprintf("Loaded: %s, Slice %d",
                                          basename, selfp->current_slice+1));
        else
            gtk_label_set_text(GTK_LABEL(selfp->w_info_label),
                               slipprintf("Loaded: %s", basename));

        gtk_window_set_title(GTK_WINDOW(self), new_title);

        if (selfp->w_info_dialog) {
            slip info = slipprintf("Filenames(%d):", selfp->cb_names->len);
            if (fli>=(int)selfp->filename_list->len)
                return;
            for (int i=0; i<(int)selfp->cb_names->len; i++) {
                gchar *fn = (gchar*)g_ptr_array_index(selfp->cb_names,
                                                      i);
                info += slipprintf("\t%s\n", fn);
            }
            if (selfp->img_org) {
                int img_w = giv_image_get_width(selfp->img_org);
                int img_h = giv_image_get_height(selfp->img_org);
                int img_depth = giv_image_get_depth(selfp->img_org);
                // Multiplication sign = \303\277 =  &#10761;
                if (img_depth > 1)
                    info += slipprintf("Resolution (w\303\227h\303\227d): %d\303\227%d\303\227%d\n"
                                       "Current slice: %d\n",
                                       img_w, img_h, img_depth,
                                       selfp->current_slice+1);
                else
                    info += slipprintf("Resolution:\t%d\303\227%d\n",
                                       img_w, img_h);
                    
                double min, max;
                giv_image_get_min_max(selfp->img_org,
                                      // output
                                      &min, &max);
                info += slipprintf("min max:\t%.6g %.6g\n", min, max);

            }
            if (selfp->img_comment) {
                info += slipprintf("\nComment:\n----------------------\n%s\n",
                                   selfp->img_comment);
            }

            // Add all attributes
            if (selfp->img_org) {
                GHashTable *attributes = giv_image_get_attribute_map(selfp->img_org);
                GHashTableIter iter;
                gpointer key, value;
    
                info += "----------------------------\nAttributes:\n";
                g_hash_table_iter_init (&iter, attributes);
                while (g_hash_table_iter_next (&iter, &key, &value)) {
                    info += slipprintf("%s: %s\n", (gchar*)key, (gchar*)value);
                }
                slip window_name = slipprintf("Info: %s", basename);
                giv_info_set_info(GIV_INFO(selfp->w_info_dialog),
                                  window_name,
                                  info);
            }
        }
        g_free(new_title);
        g_free(basename);
    }
    
    public void set_image(self,
                          GivImage *image)
    {
        if (selfp->img_org)
          {
            giv_image_unref(selfp->img_org);
            selfp->img_org = NULL;
          }
        selfp->img_org = image;
        apply_color_map(self);
        gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                   selfp->img_display);
    }

    public void redraw(self)
    {
        //        gtk_image_viewer_redraw(GTK_IMAGE_VIEWER(selfp->w_imgv), TRUE);
        gtk_widget_queue_draw(selfp->w_imgv);
    }

    /*======================================================================
    //  Make the giv window exactly big enough for the contents.
    //----------------------------------------------------------------------*/
    private void
    shrink_wrap(self)
    {
      int new_width, new_height;
      gint s_width, s_height;
      gdouble scale_x, scale_y;
      gint shift_x, shift_y;
    
      if (!selfp->w_imgv)
        return;

      gtk_image_viewer_get_scale_and_shift(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                           &scale_x, &scale_y,
                                           &shift_x, &shift_y
                                           );
    
    
      if (!selfp->img_display)
        return;
    
      s_width = gdk_screen_width ();
      s_height = gdk_screen_height ();

      new_width = (int)(gdk_pixbuf_get_width(selfp->img_display) * scale_x+1);
      new_height = (int)(gdk_pixbuf_get_height(selfp->img_display) * scale_y+1);
    
      if (new_width > 0.75*s_width)
        new_width = (int)(0.75*s_width);
      if (new_height > 0.75*s_height)
        new_height = (int)(0.75*s_height);

      // Get current scrolled win
      int old_width = gtk_widget_get_allocated_width(selfp->w_scrolled_win);
      int old_height = gtk_widget_get_allocated_height(selfp->w_scrolled_win);
#if 0
      gtk_widget_set_size_request(GTK_WIDGET(selfp->w_scrolled_win),
                                  new_width, new_height);
#endif

#if 0
      // TBD - add everything that is not part of the window
      if (GTK_WIDGET_VISIBLE(selfp->w_menubox)) 
          new_height+= selfp->w_menubox->get_allocated_height();
      new_height+= selfp->w_info_label->get_allocated_height();
#endif

      gtk_image_viewer_one_shot_block_fill_on_resize(GTK_IMAGE_VIEWER(selfp->w_imgv));
      
      int old_window_width = gtk_widget_get_allocated_width(GTK_WIDGET(self));
      int old_window_height = gtk_widget_get_allocated_height(GTK_WIDGET(self));
      gtk_window_resize(GTK_WINDOW(self),
                        old_window_width + (new_width-old_width),
                        old_window_height + (new_height-old_height) );

    }

    private bool
    read_dir_into_filename_list(self,
                                const char *path)
    {
        char *dirname = g_strdup(path);
        GError *error = NULL;

        if (selfp->filename_list) {
            g_ptr_array_foreach(selfp->filename_list, (GFunc)giv_string_array_free, NULL);
            g_ptr_array_free(selfp->filename_list, TRUE);
        }
        selfp->filename_list = g_ptr_array_new();

        if (!g_file_test(dirname, GFileTest(G_FILE_TEST_IS_DIR))) {
            g_free(dirname);
            dirname = g_path_get_dirname(path);
            if (!g_file_test(dirname, GFileTest(G_FILE_TEST_IS_DIR)))
                return false;
        }
        GDir *dir = g_dir_open(dirname, 0, &error);
        if (error) {
            app_error(self, "%s", error->message);
            g_error_free(error);
            return false;
        }
        
        const char *filename;
        while((filename = g_dir_read_name(dir))) {
            if (!g_file_test(slip(dirname)+"/"+filename,
                             GFileTest(G_FILE_TEST_IS_REGULAR)))
                continue;
                                                                    
            if (slip(filename).m("\\.(jpeg|marks|giv|pgm|ppm|png|pbm|bmp|jpg|svg|ssv|npy)$","i") || giv_plugin_supported_file(slipprintf("%s/%s", dirname, filename))) {
                GPtrArray *string_list = g_ptr_array_new();

                g_ptr_array_add(string_list,
                                g_strdup(slip(dirname) + "/" + filename));
                g_ptr_array_add(selfp->filename_list,
                                string_list);
            }
        }
        g_dir_close(dir);
        return true;
    }

    public void
    popdown_balloon(self)
    {
        giv_widget_popdown_balloon(GIV_WIDGET(selfp->w_imgv));
    }

    public GivImage *
    get_image(self)
    {
        return selfp->img_org;
    }

    public void
    update_pixelsize_info(self,
                          GString *info_label)
    {
        char format[128];
        int precision = 0;
        if (selfp->do_show_sub_pixel)
            precision = 3;

        sprintf(format, " (%%.%df,%%.%df) dist=%%.3f%%s",
                precision,precision);

        g_string_printf(info_label, format,
                         selfp->measure_x2,
                         selfp->measure_y2,
                         selfp->last_measure_distance_in_pixels*selfp->pixelsize,
                         selfp->pixelsize_unit
                         );
        if (selfp->measure_type == MEASURE_TYPE_DIAGONAL)
          g_string_append_printf(info_label,
                                 " (%.2f%s,%.2f%s)",
                                 (selfp->measure_x2 - selfp->measure_x1)*selfp->pixelsize,
                                 selfp->pixelsize_unit,
                                 (selfp->measure_y2 - selfp->measure_y1)*selfp->pixelsize,
                                 selfp->pixelsize_unit);

        // Remember the last measure text
        g_free(selfp->last_measure_text);
        selfp->last_measure_text =
            g_strdup_printf("%.5f",
                            selfp->last_measure_distance_in_pixels*selfp->pixelsize);
    }

    private const gchar *get_filetype_for_index(self,
                                                int index)
    {
        GPtrArray *string_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list, index);
        gchar *filename0 = (gchar*)g_ptr_array_index(string_list, 0);
        const gchar *dot_pos = g_strrstr(filename0, ".");
        if (!dot_pos)
            return NULL;
        return dot_pos;
    }
}

%{
static void die(const char *fmt, ...)
{
    va_list ap;
    va_start(ap,fmt); 
    
    vfprintf(stderr, fmt, ap);
    exit(-1);
}

static gboolean auto_reload_function(gpointer data)
{
    GivWin *self = GIV_WIN(data);
    gboolean do_reload = false;
    GPtrArray *fn_list =  (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                        selfp->filename_list_index);
    gchar *fn = (gchar*)g_ptr_array_index(fn_list, 0);
    struct stat st;

    stat(fn, &st);
    if (st.st_mtime != selfp->cached_mtime) {
        selfp->cached_mtime = st.st_mtime;
        selfp->auto_reload_trigger = TRUE;
        giv_win_set_current_file(self, selfp->filename_list_index);
    }

    if (!selfp->do_auto_reload)
        return FALSE;

    if (do_reload) {
        selfp->idle_handle = g_idle_add(cb_load_image_when_idle,
                                        self);
    }
    return TRUE;
}
 
/* Implement a handler for GtkUIManager's "add_widget" signal. The UI manager
 * will emit this signal whenever it needs you to place a new widget it has. */
static void
menu_add_widget (GtkUIManager *ui, GtkWidget *widget, GtkContainer *container)
{
    gtk_box_pack_start (GTK_BOX (container), widget, FALSE, FALSE, 0);
    gtk_widget_show (widget);
}

static void
cb_balloon_changed(GtkWidget *widget,
                   bool show_balloon,
                   gpointer data)
{
    GivWin *self = GIV_WIN(data);

    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->popup_manager,
                                      "/popup/ViewMenu/Balloons")),
        show_balloon);

    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/Balloons")),
        show_balloon);

}

static void
cb_marks_changed(GtkWidget *widget,
                 bool show_marks,
                 gpointer data)
{
    GivWin *self = GIV_WIN(data);

    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->popup_manager,
                                      "/popup/ViewMenu/Marks")),
        show_marks);

    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/Marks")),
        show_marks);
}


static gint
cb_button_press_event (GtkWidget * widget,
                       GdkEventButton * event,
                       gpointer user_data)
{
    GivWin *self = (GivWin *)user_data;

    giv_widget_popdown_balloon(GIV_WIDGET(selfp->w_imgv));

    if (event->button == 1 && selfp->do_pick_coordinate) {
        double world_x, world_y;
        gtk_image_viewer_canv_coord_to_img_coord(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                                 event->x, event->y,
                                                 &world_x, &world_y);
        giv_win_json_pick_reply(self, NULL, world_x, world_y);

        return true;
    }

    if (event->button == 1) {
        // check if are in measure mode ('z')
        if (selfp->is_measuring_distance
            || selfp->is_counting_marks) {
            selfp->picking_mode = dovtk_lasso_get_label_for_pixel(selfp->lasso, event->x, event->y);
            if (selfp->measure_point_index == 0
                && selfp->picking_mode) {
                selfp->picking_x = selfp->last_move_x;
                selfp->picking_y = selfp->last_move_y;
            }
            else if (0 == selfp->measure_point_index) {
                selfp->measure_x1 = selfp->last_move_x;
                selfp->measure_y1 = selfp->last_move_y;
                selfp->measure_point_index = 1;
                selfp->measure_x2 = selfp->measure_x1;
                selfp->measure_y2 = selfp->measure_y1;
            }
            else {
                selfp->measure_x2 = selfp->last_move_x;
                selfp->measure_y2 = selfp->last_move_y;
                selfp->measure_point_index = 0;
            }
            return 1;
        }
    }
    if (event->button == 3
        && !(event->state & GDK_CONTROL_MASK)
        ) {
        gtk_widget_show(selfp->w_popup);
        gtk_menu_popup (GTK_MENU (selfp->w_popup),
                        NULL, NULL, NULL, NULL,
                        event->button, event->time);
        return 1;
    }
    return 0;
}

static gint
cb_button_release_event (GtkWidget * widget,
                         GdkEventButton * event,
                         gpointer user_data)
{
    GivWin *self = (GivWin *)user_data;
    if (event->button == 2) {
#if 0
        g_signal_handler_unblock(selfp->w_imgv,
                                 selfp->cb_annotate_id);
#endif
        selfp->is_dragging = FALSE;
        giv_win_redraw(self);
    }

    if (selfp->is_counting_marks) {
      // Get image region
      GivParser *giv_parser = giv_widget_get_giv_parser(GIV_WIDGET(selfp->w_imgv));
      int num_marks =  giv_parser_count_marks(giv_parser,
                                              selfp->measure_x1,
                                              selfp->measure_y1,
                                              selfp->measure_x2,
                                              selfp->measure_y2);
      char label[64];
      sprintf(label, "%d marks in rectangle", num_marks);
      gtk_label_set_text(GTK_LABEL(selfp->w_info_label), label);
    }
    selfp->picking_mode = 0;
    selfp->measure_point_index = 0;

    return 0;
}

static gint
cb_key_press_event (GtkWidget * widget,
                    GdkEventKey * event,
                    gpointer user_data)
{
    GivWin *self = (GivWin *)user_data;
    gboolean handled = FALSE;

    // Control bindings go here
    gint k = event->keyval;
    if (event->state & GDK_CONTROL_MASK) {
        switch(k) {
            case 'd':
                {
                    // Copy the last measurement text
                    GtkClipboard* clipboard = gtk_clipboard_get(GDK_NONE);
                    gtk_clipboard_set_text(clipboard,
                                           selfp->last_measure_text,
                                           -1);
                }
                        
                return 1;
            default:
                return 0;
        }
    }
    if (k == 'a') {
        selfp->do_no_transparency = !selfp->do_no_transparency;
        giv_widget_set_do_no_transparency(GIV_WIDGET(selfp->w_imgv),
                                          selfp->do_no_transparency);
        giv_win_redraw(self);
        return 1;
    }
    if (k == 'q')
        gtk_main_quit();
    if (k== 'o')
        cb_menu_mark_browser(NULL, self);
    if (k== 'c')
        cb_menu_contrast_view(NULL, self);
    if (k== 'i')
        cb_menu_info_dialog(NULL, self);
    if (k == 'f') {
        fit_marks_in_window(self);
        return 1;
    }
    if (k=='s') {
        giv_win_shrink_wrap(self);
        return 1;
    }
    if (k==GDK_KEY_Escape)
      {
        if (selfp->do_pick_coordinate)
          giv_win_json_pick_reply(self, "Aborted", -1,-1);
      }
    if (// reload
        k == GDK_KEY_KP_Enter
        || k == GDK_KEY_Return
        // forward
        || k == ' '
        || k == GDK_KEY_Right
        || k == GDK_KEY_KP_Right
        // backward
        || k == GDK_KEY_BackSpace
        || k == GDK_KEY_Left
        || k == GDK_KEY_KP_Left
        ) {
        int index_delta = 0;

        if (k == ' '
            || k == GDK_KEY_Right
            || k == GDK_KEY_KP_Right)
            index_delta = 1;
        else if (k == GDK_KEY_BackSpace
                 || k == GDK_KEY_Left
                 || k == GDK_KEY_KP_Left )
            index_delta = -1;
#if 0
        app_error(self,
                  "filename_list.size() = %d\n",
                  selfp->filename_list.size());
#endif
        // Repeat until we have same file type
        const gchar *org_type = giv_win_get_filetype_for_index(self,selfp->filename_list_index);
        int new_index = selfp->filename_list_index;
        int s = selfp->filename_list->len;
        while(1) {
            new_index = (new_index + s + index_delta) % s;
            if (!selfp->giv_settings->do_same_filetype_on_next)
                break;

            const gchar *new_type = giv_win_get_filetype_for_index(self,new_index);
            if (org_type == NULL && new_type == NULL)
                break;
            if (!org_type || !new_type)
                continue;
            
            if (g_ascii_strcasecmp(org_type,new_type)!=0)
                continue;
            break;
        }

        if (selfp->idle_handle < 0) {
            selfp->idle_index = new_index;
            selfp->idle_handle = g_idle_add(cb_load_image_when_idle,
                                            self);
        }
                   
        //        giv_window_set_current_file(self, new_index);
        return 1;
    }
    if (k == GDK_KEY_Up
        || k == GDK_KEY_KP_Up
        || k == GDK_KEY_Down
        || k == GDK_KEY_KP_Down
        ) {
        int s = selfp->cb_names->len;
        int dir = 1;
        if (k == GDK_KEY_Down
            || k == GDK_KEY_KP_Down)
            dir = -1;

        // Check if multislice
        if (selfp->img_org && selfp->img_org->depth>1) {
          selfp->current_slice += dir;
          if (selfp->current_slice < 0)
              selfp->current_slice = selfp->img_org->depth-1;
          if (selfp->current_slice == selfp->img_org->depth)
              selfp->current_slice = 0;

          // Redraw the image
          giv_image_ref(selfp->img_org);
          giv_win_set_image(GIV_WIN(self),
                            selfp->img_org);
          giv_win_set_image_info(GIV_WIN(self));
        }
        else {
            int next_img_idx = selfp->img_in_list_idx+dir;
            // Getting next image...
            while(selfp->img_in_list_idx >= 0
                  && next_img_idx != selfp->img_in_list_idx) {
                if (next_img_idx == s)
                    next_img_idx = 0;
                if (next_img_idx < 0)
                    next_img_idx = s-1;
                slip fn = (gchar*)g_ptr_array_index(selfp->cb_names, next_img_idx);
                if (!fn.m("\\.(giv|marks)")) {
                    giv_win_load_file(self, fn);
                    selfp->img_in_list_idx = next_img_idx;
                    gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                               selfp->img_display);
                    giv_win_set_image_info(self);
                    if (selfp->do_auto_fit_marks) 
                        fit_marks_in_window(self);
    
                    break;
                }
                next_img_idx+=dir;
            }
        }
    }
    if (k == 'i') {
#if 0
        // TBD: create a popup window
        int index = selfp->filename_list_index;
        for (int i=0; i<(int)selfp->filename_list[index].size(); i++) 
            printf("%s\n",
                   selfp->filename_list[index][i].c_str());
#endif
    }
    
    return handled;
}

static gint
cb_motion_event(GtkWidget *widget,
                GdkEventMotion *event,
                gpointer user_data
                )
{
    GivWin *self = (GivWin *)user_data;
    GtkImageViewer *image_viewer = GTK_IMAGE_VIEWER(selfp->w_imgv);
    int cx = (int)event->x;
    int cy = (int)event->y;
    double x,y;
    GString *info_label = g_string_new("");
    gboolean do_update_label = true;
    bool do_update_measure_distance = false;
    
    gtk_image_viewer_canv_coord_to_img_coord(GTK_IMAGE_VIEWER(image_viewer),
                                             cx, cy, &x, &y);
    
    if (selfp->is_counting_marks) {

        if (selfp->picking_mode) {
            double dx = x - selfp->picking_x;
            double dy = y - selfp->picking_y;
            if (selfp->picking_mode == 1 || selfp->picking_mode==2) {
                selfp->measure_x1 += dx;
                selfp->measure_y1 += dy;
            }
            if (selfp->picking_mode == 1 || selfp->picking_mode==3) {
                selfp->measure_x2 += dx;
                selfp->measure_y2 += dy;
            }
            selfp->picking_x = x;
            selfp->picking_y = y;
        }
        else if (selfp->measure_point_index == 1) {
            selfp->measure_x2 = x;
            selfp->measure_y2 = y;
        }

        dovtk_lasso_update(selfp->lasso);
    }
    
    if (selfp->is_measuring_distance) {
        if (selfp->picking_mode) {
            double dx = x - selfp->picking_x;
            double dy = y - selfp->picking_y;
            if (selfp->picking_mode == 1 || selfp->picking_mode==2) {
                selfp->measure_x1 += dx;
                selfp->measure_y1 += dy;
            }
            if (selfp->picking_mode == 1 || selfp->picking_mode==3) {
                selfp->measure_x2 += dx;
                selfp->measure_y2 += dy;
            }
            selfp->picking_x = x;
            selfp->picking_y = y;
            do_update_measure_distance = true;
        }
        
        else if (selfp->measure_point_index == 1) {
            selfp->measure_x2 = x;
            selfp->measure_y2 = y;
            do_update_measure_distance = true;
#if 0
          draw_measure_line(selfp->back_store,
                            widget,
                            selfp->measure_x1, selfp->measure_y1,
                            x,y);
#endif
        }
        else
            do_update_label = false;
    }
    else if (selfp->do_show_sub_pixel)
        g_string_sprintf(info_label, " (%7.3f, %7.3f)", x, y);
    else
        g_string_sprintf(info_label, " (%4.0f, %4.0f)", floor(x), floor(y));
    
    if (do_update_measure_distance) {
        double m_dist = sqrt(sqr(selfp->measure_x2 - selfp->measure_x1)
                             + sqr(selfp->measure_y2-selfp->measure_y1));
        if (selfp->measure_type == MEASURE_TYPE_VERTICAL)
          m_dist = selfp->measure_y2-selfp->measure_y1;
        else if (selfp->measure_type == MEASURE_TYPE_HORIZONTAL)
          m_dist = selfp->measure_x2-selfp->measure_x1;

        selfp->last_measure_distance_in_pixels = m_dist;

        dovtk_lasso_update(selfp->lasso);
        giv_win_update_pixelsize_info(self, info_label);
        if (selfp->w_calibrate)
            giv_calibrate_dialog_set_last_measure_distance_in_pixels(
                GIV_CALIBRATE_DIALOG(selfp->w_calibrate),
                m_dist);
    }

    if (selfp->img_org && !selfp->is_measuring_distance) {
        int width = giv_image_get_width(selfp->img_org);
        int height = giv_image_get_height(selfp->img_org);
        
        if (x>=0 && x<width && y>=0 && y<height) {
            if (selfp->img_is_mono) {
                // TBD - clean this up so it works for arbitrary size date
                double val = giv_image_get_value(selfp->img_org,
                                                 (int)x, (int)y, selfp->current_slice);
                g_string_sprintfa(info_label, " [");
                g_string_sprintfa(info_label,
                                  selfp->format,
                                  val);
                g_string_sprintfa(info_label,
                                  "] = #%02X",
                                  (int)val);
                if (selfp->w_contrast_view)
                    giv_contrast_set_cursor_gl(GIV_CONTRAST(selfp->w_contrast_view),
                                               val);
            }
            else if (selfp->img_org->img_type == GIVIMAGE_RGBA_U8
                     || selfp->img_org->img_type == GIVIMAGE_RGBA_U16) {
                GivImageRgbAlpha16 rgba = giv_image_get_rgba_value(selfp->img_org,
                                                                   (int)x, (int)y, selfp->current_slice);
                g_string_sprintfa(info_label,
                                  " [%3d %3d %3d %3d] = #%08lX",
                                  rgba.red, rgba.green, rgba.blue, rgba.alpha,
                                  (unsigned long)(rgba.red<<24)
                                  + (rgba.green<<16)
                                  + (rgba.blue<<8)
                                  + (rgba.alpha));
            }
            else {
                GivImageRgb16 rgb = giv_image_get_rgb_value(selfp->img_org,
                                                            (int)x, (int)y, 0);
                g_string_sprintfa(info_label,
                                  " [%3d %3d %3d] = #%6X",
                                  rgb.red, rgb.green, rgb.blue,
                                  (int)(rgb.red<<16) + (rgb.green<<8) + rgb.blue);
            }
        }
    }
    
#if 0
    if (!selfp->is_dragging
        && !selfp->is_measuring_distance
        && selfp->do_show_balloon)
        giv_win_show_balloon(self,cx,cy);
#endif
    
    if (do_update_label)
        gtk_label_set_text(GTK_LABEL(selfp->w_info_label), info_label->str);
    g_string_free(info_label, TRUE);
    
    selfp->last_move_x = x;
    selfp->last_move_y = y;
    selfp->last_cx = cx;
    selfp->last_cy = cy;
    
    return FALSE;
}

static void cb_view_menu_bar (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    if (gtk_widget_is_visible(selfp->w_menubox))
        gtk_widget_hide(selfp->w_menubox);
    else
        gtk_widget_show(selfp->w_menubox);
}

static void cb_view_marks (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    gboolean do_view_marks = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(action));
    giv_widget_set_show_marks(GIV_WIDGET(selfp->w_imgv),do_view_marks);
}

static void cb_view_balloons (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    giv_widget_set_show_balloon(GIV_WIDGET(selfp->w_imgv),
                                gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(action)));

}

static void cb_view_sub_pixel (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    selfp->do_show_sub_pixel = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(action));
}

static void cb_view_hflip (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    gboolean do_vertical_flip, do_horizontal_flip;
    gtk_image_viewer_get_flip(GTK_IMAGE_VIEWER(selfp->w_imgv),
                              &do_horizontal_flip,
                              &do_vertical_flip);
    do_horizontal_flip = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(action));

    gtk_image_viewer_set_flip(GTK_IMAGE_VIEWER(selfp->w_imgv),
                              do_horizontal_flip,
                              do_vertical_flip);
}

static void cb_view_vflip (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    gboolean do_vertical_flip, do_horizontal_flip;
    gtk_image_viewer_get_flip(GTK_IMAGE_VIEWER(selfp->w_imgv),
                              &do_horizontal_flip,
                              &do_vertical_flip);
    do_vertical_flip = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(action));

    gtk_image_viewer_set_flip(GTK_IMAGE_VIEWER(selfp->w_imgv),
                              do_horizontal_flip,
                              do_vertical_flip);
}

static void cb_view_vertical_zoom_lock (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    gboolean do_vlock;

    do_vlock = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(action));

    gtk_image_viewer_set_vertical_lock(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                       do_vlock);
}

static void cb_view_colormap (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    // Sync the variable state with the toolbar.
    selfp->do_view_colormap =
        gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(gtk_ui_manager_get_widget(selfp->menu_manager,
                                                                                     "/menubar/ViewMenu/ColorMapBar")));

    if (selfp->do_view_colormap)
        gtk_widget_show(selfp->w_color_map_bar);
    else
        gtk_widget_hide(selfp->w_color_map_bar);
}

static void cb_view_pixel_grid (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    GtkWidget *menu_widget = gtk_ui_manager_get_widget(selfp->menu_manager,
                                                       "/menubar/ViewMenu/ViewPixelGrid");

    gboolean old_val = gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(menu_widget));
    giv_widget_set_show_grid(GIV_WIDGET(selfp->w_imgv), !old_val);
    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menu_widget), !old_val);

    giv_win_redraw(self);
}

static void cb_view_auto_resize (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    selfp->do_auto_fit_marks = !selfp->do_auto_fit_marks;
    gtk_image_viewer_set_fill_on_resize(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                        selfp->do_auto_fit_marks);
    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/AutoResize")),
        selfp->do_auto_fit_marks);

    if (selfp->do_auto_fit_marks)
        fit_marks_in_window(self);
}

static void cb_view_auto_contrast (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    selfp->do_auto_contrast = !selfp->do_auto_contrast;
    if (selfp->w_contrast_view)
        giv_contrast_set_do_auto_contrast(GIV_CONTRAST(selfp->w_contrast_view),
                                          selfp->do_auto_contrast);
    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/AutoContrast")),
        selfp->do_auto_contrast);

    if (selfp->do_auto_contrast)
        cb_load_image_when_idle(self);
}

static void cb_view_auto_reload (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    selfp->do_auto_reload = !selfp->do_auto_reload;
    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/AutoReload")),
        selfp->do_auto_reload);

    if (selfp->do_auto_reload)
        g_timeout_add(250, auto_reload_function, self);
}

static void
app_error (GivWin *self,
           const char *format, ...)
{
    va_list ap;
    va_start(ap,format);
    gchar *message = g_strdup_vprintf(format, ap);
    GtkWidget *dialog;

    dialog = gtk_message_dialog_new (GTK_WINDOW(self),
                                     GTK_DIALOG_DESTROY_WITH_PARENT,
                                     GTK_MESSAGE_ERROR,
                                     GTK_BUTTONS_CLOSE,
                                     message);
    gtk_window_set_keep_above(GTK_WINDOW(dialog), true);
    gtk_dialog_run (GTK_DIALOG (dialog));
    gtk_widget_destroy (dialog);
    g_free(message);
  
    return;
}

static gint
cb_mark_tree_destroy(GtkWidget *dialog,
                     gpointer data)
{
    GivWin *self = GIV_WIN(data);
    selfp->w_mark_tree_dialog = NULL;
    return 0;
}

static gint
cb_contrast_view_destroy(GtkWidget *dialog,
                         gpointer data)
{
    GivWin *self = GIV_WIN(data);
    selfp->w_contrast_view = NULL;
    return 0;
}

static gint
cb_info_destroy(GtkWidget *dialog,
                gpointer data)
{
    GivWin *self = GIV_WIN(data);
    selfp->w_info_dialog = NULL;
    return 0;
}

void
cb_menu_mark_browser (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    if (selfp->w_mark_tree_dialog)
        return;
    selfp->w_mark_tree_dialog = giv_mark_tree_dialog_new(self);
    g_signal_connect(selfp->w_mark_tree_dialog, "destroy",
                     G_CALLBACK(cb_mark_tree_destroy), self);

    gtk_widget_show_all(selfp->w_mark_tree_dialog);

    return;
}

void
cb_menu_contrast_view (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    if (selfp->w_contrast_view)
        return;
    selfp->w_contrast_view = giv_contrast_new(self);
    g_signal_connect(selfp->w_contrast_view, "contrast-changed",
                     G_CALLBACK(cb_contrast_changed), self);
    g_signal_connect(selfp->w_contrast_view, "destroy",
                     G_CALLBACK(cb_contrast_view_destroy), self);
    giv_contrast_set_do_auto_contrast(GIV_CONTRAST(selfp->w_contrast_view),
                                      selfp->do_auto_contrast);
    gtk_widget_show_all(selfp->w_contrast_view);

    return;
}

void
cb_menu_info_dialog (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    if (selfp->w_info_dialog)
        return;
    selfp->w_info_dialog = giv_info_new(self);
    g_signal_connect(selfp->w_info_dialog, "destroy",
                     G_CALLBACK(cb_info_destroy), self);

    gtk_widget_show_all(selfp->w_info_dialog);
    giv_win_set_image_info(self);

    return;
}

static gint
cb_preferences_response(GtkWidget *dialog,
                        gint response_id,
                        gpointer user_data)
{
    GivWin *self = GIV_WIN(user_data);

    if (response_id == GTK_RESPONSE_APPLY
        || response_id == GTK_RESPONSE_ACCEPT) {
        giv_settings_editor_apply(GIV_SETTINGS_EDITOR(selfp->w_preferences));
        giv_settings_save_prefs(GIV_SETTINGS(selfp->giv_settings));
    }

    if (response_id == GTK_RESPONSE_CANCEL
        || response_id == GTK_RESPONSE_ACCEPT) {
        gtk_widget_destroy (selfp->w_preferences);
        selfp->w_preferences = NULL;
    }

    return 0;
}

static void
cb_menu_preferences (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    if (selfp->w_preferences)
        return;

    selfp->w_preferences = giv_settings_editor_new(GIV_SETTINGS(selfp->giv_settings));

    g_signal_connect (selfp->w_preferences,
                      "response",
                      G_CALLBACK (cb_preferences_response),
                      self);
#if 0
    g_object_add_weak_pointer(G_OBJECT(selfp->w_preferences),
                              (void**)selfp->w_preferences);
#endif

    gtk_widget_show_all(selfp->w_preferences);

    return;
}

void
cb_menu_quiver_zoom (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    
    selfp->is_quiver_zoom = !selfp->is_quiver_zoom;
  
    return;
}

void
cb_menu_count_marks (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    // Silently ignore if we are measuring distances
    if (selfp->is_measuring_distance)
        return;
    
    selfp->is_counting_marks = !selfp->is_counting_marks;
    if (selfp->is_counting_marks) {
      //        selfp->back_store = create_backstore(selfp->w_imgv);
        selfp->measure_x1=-1;
        selfp->measure_y1=-1;
        selfp->lasso = dovtk_lasso_create(selfp->w_imgv,
                                          &my_lasso_draw_rectangle,
                                          self);
    }
    else {
        //free_giv_backstore (selfp->back_store);
        //selfp->back_store = NULL;
        dovtk_lasso_destroy(selfp->lasso);
        selfp->lasso = NULL;
        gdk_window_set_cursor(gtk_widget_get_window(selfp->w_imgv), NULL);
        selfp->current_cursor = NULL;
    }
  
    return;
}

static void
menu_measure_distance (GivWin *self, GtkAction *action, int measure_type)
{
    // Reference: http://www.gtkforums.com/viewtopic.php?t=4173
    int signal_id = g_signal_lookup("activate", GTK_TYPE_ACTION);

    struct {
        const char *action_name;
        int measure_type;
    } actions[] {
        { "ToolMeasureDistanceDiagonalAction", MEASURE_TYPE_DIAGONAL },
        { "ToolMeasureDistanceHorizontalAction", MEASURE_TYPE_HORIZONTAL },
        { "ToolMeasureDistanceVerticalAction", MEASURE_TYPE_VERTICAL }};
                
    selfp->is_measuring_distance = TRUE;
    for (auto act : actions) {
        GtkAction *action
            = gtk_action_group_get_action(selfp->toggle_actions,
                                          act.action_name);
        gboolean is_active = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(action));

        // This is the current action that was toggled.
        if (act.measure_type == measure_type) {
            if (!is_active)
                selfp->is_measuring_distance = FALSE;
        }

        // These are the other actions that should always be turned off. But
        // we don't want to trigger an action when they are changed!
        else if (act.measure_type == selfp->measure_type && is_active) {
            int handler_id = g_signal_handler_find(action,
                                                   G_SIGNAL_MATCH_ID,
                                                   signal_id,
                                                   0,NULL,NULL,NULL);

            g_signal_handler_block(action, handler_id);
            gtk_toggle_action_set_active(GTK_TOGGLE_ACTION(action), false);
            g_signal_handler_unblock(action, handler_id);
        }
    }

    if (selfp->is_measuring_distance) {
        selfp->measure_type = measure_type;
        selfp->measure_x1=-1;
        selfp->measure_y1=-1;
        if (!selfp->lasso)
            selfp->lasso = dovtk_lasso_create(selfp->w_imgv,
                                              &my_lasso_draw,
                                              self);
        else
            dovtk_lasso_update(selfp->lasso);
    }
    else
      {
        // TBD - reset the menus.
        //free_giv_backstore (selfp->back_store);
        //selfp->back_store = NULL;
        gdk_window_set_cursor(gtk_widget_get_window(selfp->w_imgv), NULL);
        dovtk_lasso_destroy(selfp->lasso);
        selfp->lasso = NULL;
      }
  
    return;
}

void
cb_menu_measure_distance_diagonal (GtkAction *action, gpointer data)
{
  GivWin *self = GIV_WIN(data);

  menu_measure_distance(self, action, MEASURE_TYPE_DIAGONAL);
}

void
cb_menu_measure_distance_horizontal (GtkAction *action, gpointer data)
{
  GivWin *self = GIV_WIN(data);

  menu_measure_distance(self, action, MEASURE_TYPE_HORIZONTAL);
}

void
cb_menu_measure_distance_vertical (GtkAction *action, gpointer data)
{
  GivWin *self = GIV_WIN(data);

  menu_measure_distance(self, action, MEASURE_TYPE_VERTICAL);
}

static gint
cb_calibrate_destroy(GtkWidget *dialog,
                     gpointer data)
{
    GivWin *self = GIV_WIN(data);
    selfp->w_calibrate = NULL;
    return 0;
}

static void
cb_calib_changed(GtkWidget *calib_dialog,
                 double pixelsize,
                 const char *unit,
                 gpointer user_data)
{
    GivWin *self = GIV_WIN(user_data);

    selfp->pixelsize = pixelsize;
    g_free(selfp->pixelsize_unit);
    selfp->pixelsize_unit = g_strdup(unit);
    if (selfp->lasso)
        dovtk_lasso_update(selfp->lasso);

    GString *info_label = g_string_new("");
    giv_win_update_pixelsize_info(self, info_label);
    gtk_label_set_text(GTK_LABEL(selfp->w_info_label), info_label->str);
    g_string_free(info_label, TRUE);
}

static void
cb_menu_calibrate (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    if (selfp->w_calibrate)
        return;
    selfp->w_calibrate = giv_calibrate_dialog_new(self,
                                                  selfp->pixelsize,
                                                  selfp->pixelsize_unit,
                                                  selfp->last_measure_distance_in_pixels);
    g_signal_connect(selfp->w_calibrate, "destroy",
                     G_CALLBACK(cb_calibrate_destroy), self);
    g_signal_connect(selfp->w_calibrate, "calib-changed",
                     G_CALLBACK(cb_calib_changed), self);
    gtk_widget_show_all(selfp->w_calibrate);

    return;
}

#if 0
void
cb_menu_default (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    app_error(self, "Sorry. Not implemented yet");
  
    return;
}
#endif

static void
cb_menu_fill (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    fit_marks_in_window(self);
  
    return;
}

static void
cb_menu_shrink_wrap (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    giv_win_shrink_wrap(self);
  
    return;
}

// Have to decide exactly what I am supposed to load in the new window...
void
cb_menu_new_window (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    GtkWidget *w_new_giv = giv_win_new(0, NULL);
    giv_image_ref(selfp->img_org);
    giv_win_set_image(GIV_WIN(w_new_giv),
                      selfp->img_org);
    gtk_widget_show(w_new_giv);
  
    return;
}

void
cb_menu_close_window (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    gtk_widget_destroy(GTK_WIDGET(self));
  
    return;
}

void
cb_menu_clear (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    giv_widget_clear_giv(GIV_WIDGET(selfp->w_imgv));
    giv_image_unref(selfp->img_org);
    selfp->img_org = NULL;
    g_object_unref(selfp->img_display);
    selfp->img_display = NULL;
    gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv), NULL);
    
    return;
}

static void
cb_menu_open_response(GtkWidget *dialog,
                        gint response,
                        gpointer user_data)
{
    GivWin *self = GIV_WIN(user_data);

    if (response == GTK_RESPONSE_ACCEPT) {
        gchar *selected_filename = 
            gtk_file_chooser_get_filename (GTK_FILE_CHOOSER(selfp->w_filechooser));

        char *basename = g_path_get_basename(selected_filename);
        giv_win_read_dir_into_filename_list(self, selected_filename);
        selfp->filename_list_index = -1;
        for (int i=0; i<(int)selfp->filename_list->len; i++) {
            GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                               i);
            if (g_str_has_suffix((const gchar*)g_ptr_array_index(fn_list, 0),
                                 basename)) {
                selfp->filename_list_index = i;
                break;
            }
        }
        g_free(basename);
        if (selfp->filename_list->len
            && selfp->filename_list_index < 0) {
            GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                               0);
            
            giv_win_load_file(self, (gchar*)g_ptr_array_index(fn_list, 0));
            selfp->filename_list_index = 0;
        }
        else
            giv_win_set_current_file(self,
                                        selfp->filename_list_index);

#if 0
        giv_win_load_file(self, selected_filename);
#endif
        if (last_image_path)
            g_free(last_image_path);
        last_image_path = selected_filename;
    }
    gtk_widget_destroy (selfp->w_filechooser);
    selfp->w_filechooser = NULL;
}

void
cb_menu_open (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    selfp->w_filechooser = gtk_file_chooser_dialog_new ("Open File",
                                                GTK_WINDOW (self),
                                                GTK_FILE_CHOOSER_ACTION_OPEN,
                                                GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
                                                NULL);

#if 0
    gtk_window_set_transient_for (GTK_WINDOW (selfp->w_filechooser),
                                  GTK_WINDOW (self));
#endif
    gtk_dialog_set_default_response ( GTK_DIALOG(selfp->w_filechooser),
                                      GTK_RESPONSE_ACCEPT);

    if (last_image_path)
        gtk_file_chooser_set_filename (GTK_FILE_CHOOSER (selfp->w_filechooser),
                                       last_image_path);

    g_signal_connect (G_OBJECT (selfp->w_filechooser), 
                      "response", 
                      G_CALLBACK (cb_menu_open_response),
                      self);

    /* Display that dialog */
    gtk_widget_show_all (selfp->w_filechooser);

    return;
}

static void
export_to_file(GivWin *self,
               int width,
               int height,
               const char *filename)
{
    char *basename = g_path_get_basename(filename);
    printf("Exporting to  %s\n", filename);
    
    if (is_file_ext(basename, "svg|pdf|ps")) {
        cairo_surface_t *surface = NULL;
        if (is_file_ext(basename, "svg")) 
            surface = cairo_svg_surface_create(filename,
                                               width,
                                               height);
        else if (is_file_ext(basename, "svg")) 
            surface = cairo_ps_surface_create(filename,
                                              width,
                                              height);
        else if (is_file_ext(basename, "pdf"))
            surface = cairo_pdf_surface_create(filename,
                                               width,
                                               height);
        
        cairo_t *cr = cairo_create(surface);
        draw_to_cairo(cr, width, height, self);
        cairo_destroy (cr);
        cairo_surface_destroy(surface);
    }
    else if (is_file_ext(basename, "png")) {
        cairo_surface_t *surface_image = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
                                                                    width,
                                                                    height);
        cairo_t *cr = cairo_create(surface_image);

        draw_to_cairo(cr, width, height, self);

        cairo_destroy (cr);
        if (cairo_surface_write_to_png (surface_image, filename)
            != CAIRO_STATUS_SUCCESS) {
            app_error(self,
                      "Failed saving image to %s!\n",
                      filename);
        }
        cairo_surface_destroy(surface_image);
    }
    else
        app_error(self,
                  "Unsupported file type for exporting.\n"
                  "Supported types are svg, ps, pdf, and png\n");
}

static void
cb_menu_export_response(GtkWidget *dialog,
                        gint response,
                        gpointer user_data)
{
    GivWin *self = GIV_WIN(user_data);

    if (response == GTK_RESPONSE_ACCEPT)
      {
        int width = gtk_widget_get_allocated_width(GTK_WIDGET(selfp->w_imgv));
        int height = gtk_widget_get_allocated_height(GTK_WIDGET(selfp->w_imgv));
        gchar *selected_filename = 
            gtk_file_chooser_get_filename (GTK_FILE_CHOOSER(selfp->w_filechooser));

        export_to_file(self, width, height, selected_filename);
    }
    gtk_widget_destroy (selfp->w_filechooser);
    selfp->w_filechooser = NULL;
}

void
cb_menu_export (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);

    selfp->w_filechooser
        = gtk_file_chooser_dialog_new ("Export File",
                                       GTK_WINDOW (self),
                                       GTK_FILE_CHOOSER_ACTION_SAVE,
                                       GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                       GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
                                       NULL);

    gtk_dialog_set_default_response ( GTK_DIALOG(selfp->w_filechooser),
                                      GTK_RESPONSE_ACCEPT);

    if (last_export_image_path) 
        gtk_file_chooser_set_filename (GTK_FILE_CHOOSER (selfp->w_filechooser),
                                       last_export_image_path);
    else if (last_image_path) 
        gtk_file_chooser_set_filename (GTK_FILE_CHOOSER (selfp->w_filechooser),
                                       last_image_path);

    g_signal_connect (G_OBJECT (selfp->w_filechooser), 
                      "response", 
                      G_CALLBACK (cb_menu_export_response),
                      self);

    /* Display that dialog */
    gtk_widget_show_all (selfp->w_filechooser);

    return;
}

void begin_print(GtkPrintOperation *operation,
                 GtkPrintContext   *context,
                 gpointer           user_data)
{
    g_object_set(G_OBJECT(operation),
                 "n-pages", 1,
                 NULL);
}

/** 
 * 
 * 
 * @param cr 
 * @param width 
 * @param height 
 * @param do_print_shift_adjust Whether to shift and adjust page suitable for printing
 * @param self 
 */
void draw_to_cairo(cairo_t *cr,
                   int width,
                   int height,
                   GivWin *self)
{
    GivParser *parser = giv_widget_get_giv_parser(GIV_WIDGET(selfp->w_imgv));
    GPtrArray *datasets = giv_parser_get_giv_datasets(parser);
    double scale_x, scale_y;
    gint shift_x, shift_y;
    
    gtk_image_viewer_get_scale_and_shift(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                         &scale_x, &scale_y,
                                         &shift_x, &shift_y);
    // TBD: * turn on cairo clip area
    //      * draw image
    int cnv_width = gtk_widget_get_allocated_width(selfp->w_imgv);
    int cnv_height = gtk_widget_get_allocated_height(selfp->w_imgv);
    if (cnv_width <= 1)
      {
        cnv_width = width;
        cnv_height = height;
      }

    cairo_set_line_width (cr, 2);
    cairo_rectangle(cr, 0,0,cnv_width, cnv_height);
    cairo_stroke_preserve(cr);
    cairo_clip(cr);

#ifdef PRINT_BY_IMAGE
    // Draw img_display
    GdkPixbuf *img_scaled, *cimg;
    GdkInterpType interp_type = GDK_INTERP_NEAREST;
    int dst_x = 0, dst_y = 0;
    double super_res = 4;
    int dwidth = gdk_pixbuf_get_width(selfp->img_display);
    int dheight = gdk_pixbuf_get_width(selfp->img_display);
    int copy_w = cnv_width*super_res;
    int copy_h = cnv_height*super_res;

    img_scaled = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
                                TRUE,
                                8,
                                cnv_width*super_res,
                                cnv_height*super_res);
    gdk_pixbuf_fill(img_scaled,
                    0xffffffff);

    if (dwidth * scale_x *super_res < cnv_width) {
        dst_x = (cnv_width-dwidth*scale_x*super_res)/2;
        copy_w = dwidth*scale_x*super_res;
    }
    if (dheight * scale_y *super_res < cnv_height) {
        dst_y = (cnv_height-dheight*scale_y*super_res)/2;
        copy_h = dheight*scale_y*super_res;
    }

    if (selfp->img_display) {
        gdk_pixbuf_scale(selfp->img_display,
                         img_scaled,
                         dst_x,dst_y,
                         copy_w,
                         copy_h,
                         -shift_x,
                         -shift_y,
                         scale_x, scale_y,
                         interp_type);
    }

    GivPainterCairoPixbuf painter(img_scaled, true);

    GivRenderer renderer(datasets, painter,
                         scale_x, scale_y,
                         shift_x, shift_y,
                         cnv_width, cnv_height);
    renderer.set_do_no_transparency(selfp->do_no_transparency);
    renderer.paint();

    pixbuf_to_cairo(img_scaled,
                    // output
                    &cimg);

    cairo_surface_t* img_srf
        = cairo_image_surface_create_for_data(gdk_pixbuf_get_pixels(cimg),
                                              CAIRO_FORMAT_ARGB32,
                                              gdk_pixbuf_get_width(cimg),
                                              gdk_pixbuf_get_height(cimg),
                                              gdk_pixbuf_get_rowstride(cimg));

    

    cairo_set_source_surface(cr, img_srf, 0, 0);
    cairo_paint(cr);
    cairo_surface_destroy(img_srf);
    g_object_unref(cimg);
    g_object_unref(img_scaled);
#else
    if (selfp->img_display) {
        // Draw img_display
        GdkPixbuf *cimg;
        
        pixbuf_to_cairo(selfp->img_display,
                        // output
                        &cimg);
        
        cairo_surface_t* img_srf
            = cairo_image_surface_create_for_data(gdk_pixbuf_get_pixels(cimg),
                                                  CAIRO_FORMAT_ARGB32,
                                                  gdk_pixbuf_get_width(cimg),
                                                  gdk_pixbuf_get_height(cimg),
                                                  gdk_pixbuf_get_rowstride(cimg));

        cairo_save(cr);
        cairo_translate(cr, -shift_x, -shift_y);
        cairo_scale(cr, scale_x, scale_y);
        cairo_set_source_surface(cr, img_srf, 0, 0);
        cairo_paint(cr);
        cairo_restore(cr);
        cairo_surface_destroy(img_srf);
        g_object_unref(cimg);
    }

    bool show_marks = giv_widget_get_show_marks(GIV_WIDGET(selfp->w_imgv));
    if (show_marks) {
        GivPainterCairo painter(cr);
        GivRenderer renderer(datasets, painter,
                             scale_x, scale_y,
                             shift_x, shift_y,
                             cnv_width, cnv_height,
                             giv_widget_get_quiver_scale(GIV_WIDGET(selfp->w_imgv)));
        renderer.set_do_no_transparency(selfp->do_no_transparency);
        renderer.paint();
    }
#endif
}

void draw_page (GtkPrintOperation *operation,
                GtkPrintContext   *context,
                gint               page_nr,
                gpointer           user_data)
{
    GivWin *self = GIV_WIN(user_data);
    cairo_t *cr;
    gdouble width, height;

    cr = gtk_print_context_get_cairo_context (context);
    width = gtk_print_context_get_width (context);
    height = gtk_print_context_get_height (context);

    //      * draw image
    int cnv_width = gtk_widget_get_allocated_width(selfp->w_imgv);

    // shift adjust for printing
    double draw_width = 150; // mm
    cairo_translate(cr, (210-draw_width)/2, 0);
    double scale = 1.0*draw_width/cnv_width;
    cairo_scale(cr, scale, scale);

    draw_to_cairo(cr, width, height, self);
}

void
cb_menu_print (GtkAction *action, gpointer data)
{
    GivWin *self = GIV_WIN(data);
    GtkPrintOperation *print;
    GtkPrintOperationResult res;
    
    print = gtk_print_operation_new ();
    // The following should be made more advanced for windows...
    gtk_print_operation_set_unit(print, GTK_UNIT_MM);
    
    if (selfp->print_settings != NULL) 
        gtk_print_operation_set_print_settings (print, selfp->print_settings);
    
    g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), self);
    g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), self);

    res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
                                   GTK_WINDOW (self), NULL);
    
    if (res == GTK_PRINT_OPERATION_RESULT_APPLY) {
        if (selfp->print_settings != NULL)
            g_object_unref (selfp->print_settings);
        selfp->print_settings = GTK_PRINT_SETTINGS(g_object_ref (gtk_print_operation_get_print_settings (print)));
    }
    
    g_object_unref (print);
    
    return;
}

static void
cb_menu_about(GtkAction *action,
	      gpointer data)
{
    GivWin *self = GIV_WIN(data);
    GtkWidget *about_window;
    GtkWidget *vbox;
    GtkWidget *label, *w_image;
    GdkPixbuf *icon;
    gchar *markup;
    GError *err = NULL;
  
    about_window = gtk_dialog_new ();
    gtk_window_set_transient_for(GTK_WINDOW(about_window),
                                 GTK_WINDOW(self));
    gtk_dialog_add_button (GTK_DIALOG (about_window),
                           GTK_STOCK_OK, GTK_RESPONSE_OK);
    gtk_dialog_set_default_response (GTK_DIALOG (about_window),
                                     GTK_RESPONSE_OK);
  
    gtk_window_set_title(GTK_WINDOW (about_window), "giv");
  
    gtk_window_set_resizable (GTK_WINDOW (about_window), FALSE);

#if 0
    g_signal_connect (G_OBJECT (about_window), "delete-event",
                      G_CALLBACK (gtk_widget_destroy), about_window);
#endif
  
    vbox = gtk_vbox_new (FALSE, 0);
    gtk_container_set_border_width (GTK_CONTAINER (vbox), 6);
    gtk_box_pack_start (GTK_BOX (gtk_dialog_get_content_area(GTK_DIALOG (about_window))), vbox, FALSE, FALSE, 0);

    icon = gdk_pixbuf_new_from_inline(sizeof(logo_150_inline),
                                      logo_150_inline,
                                      FALSE,
                                      &err);
    w_image = gtk_image_new_from_pixbuf(icon);

    gtk_box_pack_start (GTK_BOX (vbox), w_image, FALSE, FALSE, 0);

    label = gtk_label_new (NULL);
    gtk_label_set_selectable(GTK_LABEL(label), TRUE);
    gtk_misc_set_alignment (GTK_MISC (label), 0.5, 0.5);
    gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_CENTER);
    markup = g_strdup_printf ("<span size=\"xx-large\" weight=\"bold\">Giv " VERSION"</span>\n\n"
                              "%s\n"
                              "Homepage: http://giv.sourceforge.net/giv"
                              "\n"
                              "<span>%s\n%sEmail: <tt>&lt;%s&gt;</tt>\n"
                              "Commit-Id: %s\n"
                              "Commit-Date: %s</span>\n"
                              ,
                              ("The G(reat|tk) Image Viewer"),
                              ARCH,
                              ("Copyright &#x00a9; Dov Grobgeld, 2018\n"),
                              ("dov.grobgeld@gmail.com"),
                              GIT_COMMIT_ID,
                              GIT_COMMIT_TIME);
    gtk_label_set_markup (GTK_LABEL (label), markup);
    g_free (markup);
    gtk_box_pack_start (GTK_BOX (vbox), label, TRUE, TRUE, 0);
  
    gtk_widget_show_all (about_window);
    gtk_dialog_run (GTK_DIALOG (about_window));
    gtk_widget_destroy (about_window);
}

static void
cb_menu_manual(GtkAction *action,
               gpointer data)
{
#ifdef WIN32
    // Fix the path
    ShellExecute(NULL, "open", "file:///c|/Progra~1/giv/doc/giv.html", NULL, NULL, SW_SHOWNORMAL);
#else
    // Linux
    system(slipprintf("xdg-open %s/giv.html",
                      PACKAGE_DOC_DIR));
#endif
}

static void
cb_menu_copyright(GtkAction *action,
                  gpointer data)
{
    GtkWidget *copyright_window;
    GtkWidget *scroll_window;
    GtkWidget *w_text;
    GtkTextIter end_iter;
    GtkTextBuffer *text_buffer;
  
    copyright_window = gtk_dialog_new ();
#if 0
    gtk_window_set_transient_for(GTK_WINDOW(copyright_window),
                                 GTK_WINDOW(self));
#endif
    gtk_dialog_add_button (GTK_DIALOG (copyright_window),
                           GTK_STOCK_OK, GTK_RESPONSE_OK);
    gtk_dialog_set_default_response (GTK_DIALOG (copyright_window),
                                     GTK_RESPONSE_OK);
  
    gtk_window_set_title(GTK_WINDOW (copyright_window), "Giv Copyright");

#if 0
    g_signal_connect (G_OBJECT (copyright_window), "delete-event",
                      G_CALLBACK (gtk_widget_destroy), copyright_window);
#endif
  
    // Insert copyright here
    scroll_window = gtk_scrolled_window_new(NULL, NULL);
    gtk_box_pack_start(GTK_BOX(gtk_dialog_get_content_area(GTK_DIALOG(copyright_window))),
                       scroll_window, TRUE, TRUE, 0);

    w_text = gtk_text_view_new ();
#if 0
    // why does this make the bell ring?
    gtk_text_view_set_editable      (GTK_TEXT_VIEW(w_text), FALSE);
#endif
    gtk_text_view_set_cursor_visible (GTK_TEXT_VIEW(w_text), FALSE);
    gtk_text_view_set_wrap_mode (GTK_TEXT_VIEW(w_text), GTK_WRAP_NONE);
    gtk_widget_set_size_request (w_text, 600, 500);
    gtk_container_add(GTK_CONTAINER(scroll_window),
                      w_text);
    text_buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (w_text));
    
    gtk_text_buffer_get_end_iter(text_buffer,
                                 &end_iter);
    giv_text_buffer_insert_markup(text_buffer,
                                  &end_iter,
                                  copyright_string);

    gtk_widget_show_all (copyright_window);
    gtk_dialog_run (GTK_DIALOG (copyright_window));
    gtk_widget_destroy (copyright_window);
}

static int
cb_image_size_alloc(GtkWidget *widget,
                    GtkAllocation *allocation,
                    gpointer           user_data)
{
    return 0;
}
    
static void
cb_flip_changed(GtkImageViewer *imgv,
                gboolean do_flip_horizontal,
                gboolean do_flip_vertical,
                gpointer data)
{
    GivWin *self = GIV_WIN(data);

    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/HorizontalFlip")),
        do_flip_horizontal);
    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/VerticalFlip")),
        do_flip_vertical);
    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->popup_manager,
                                      "/popup/ViewMenu/HorizontalFlip")),
        do_flip_horizontal);
    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->popup_manager,
                                      "/popup/ViewMenu/VerticalFlip")),
        do_flip_vertical);
}        
 
static void
cb_vertical_zoom_lock_changed(GtkImageViewer *imgv,
                              gboolean do_vertical_lock,
                              gpointer data)
{
    GivWin *self = GIV_WIN(data);
    gtk_check_menu_item_set_active(
        GTK_CHECK_MENU_ITEM(
            gtk_ui_manager_get_widget(selfp->menu_manager,
                                      "/menubar/ViewMenu/VerticalLock")),
        do_vertical_lock);
  
}

static inline gboolean
line_hor_line_intersect(double x0, double y0, double x1, double y1,
                        double line_x0, double line_x1, double line_y,
                        /* output */
                        double *x_cross, double *y_cross)
{
  if (y1 == y0) {
    *y_cross = x0;
    *x_cross = 0; /* Any x is a crossing */
    if (y1 == line_y)
      return TRUE;
    return FALSE;
  }

  *y_cross = line_y; /* Obviously! */
  *x_cross = x0 + (x1 - x0)*(line_y - y0)/(y1-y0);

  if (y1<y0) {
    double tmp = y0;
    y0=y1;
    y1=tmp;
  }

  return (*x_cross >= line_x0 && *x_cross <= line_x1 && *y_cross >= y0 && *y_cross <= y1);
}

static inline gboolean
line_ver_line_intersect(double x0, double y0, double x1, double y1,
                        double line_y0, double line_y1, double line_x,
                        /* output */
                        double *x_cross, double *y_cross)
{
  if (x1 == x0) {
    *x_cross = x0;
    *y_cross = 0; /* Any y is a crossing */
    if (x1 == line_x)
      return TRUE;
    return FALSE;
  }


  *x_cross = line_x; /* Obviously! */
  *y_cross = y0 + (y1 - y0)*(line_x - x0)/(x1-x0);

  if (x1<x0) {
    double tmp = x0;
    x0=x1;
    x1=tmp;
  }
  return (*y_cross >= line_y0 && *y_cross <= line_y1 && *x_cross >= x0 && *x_cross <= x1);
}

#if 0
static gboolean
giv_check_img_for_mono(GdkPixbuf *im)
{
    int pix_idx;
    int width = gdk_pixbuf_get_width(im);
    int height = gdk_pixbuf_get_height(im);
    guint8 *buf = gdk_pixbuf_get_pixels(im);
    
    for(pix_idx=0; pix_idx<width * height; pix_idx++) {
        if (buf[0] != buf[1]
            || buf[0] != buf[2])
            return FALSE;
        buf+= 3;
    }
    return TRUE;
}
#endif

static gboolean
giv_check_img_for_mono(GivImage *im)
{
    int width = giv_image_get_width(im);
    int height = giv_image_get_height(im);

    // Easy path if there is no color
    if (!giv_image_get_is_color(im))
        return TRUE;

    // Assume color and check
    for (int row_idx=0; row_idx<height; row_idx++) {
        for (int col_idx=0; col_idx<width; col_idx++) {
            GivImageRgb16 rgb = giv_image_get_rgb_value(im,
                                                        col_idx, row_idx, 0);
            if (rgb.red != rgb.green
                || rgb.red != rgb.blue) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

static void
cb_change_pseudo_color(GtkRadioAction* action,
                       GtkRadioAction*,
                       GivWin *self)
{
    int value = gtk_radio_action_get_current_value(action);
    selfp->colormap = value;
    apply_color_map(self);
    gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv),
                               selfp->img_display);
    giv_win_redraw(self);
}

static void
cb_contrast_changed(GtkWidget* widget,
                    double contrast_min,
                    double contrast_max,
                    GivWin *self)
{
    selfp->contrast_min = contrast_min;
    selfp->contrast_max = contrast_max;
    apply_color_map(self);
    gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv),
                               selfp->img_display);
    giv_color_map_set_min_max(GIV_COLOR_MAP(selfp->w_color_map_bar),
                              contrast_min, contrast_max);
    giv_win_redraw(self);
}

static void
apply_color_map(GivWin *self)
{
    if (selfp->img_display)
    {
      g_object_unref(selfp->img_display);
      selfp->img_display = NULL;
    }

    if (!selfp->img_org)
        return;

    /* Color maps */
    struct color_maps_struct {
      const char *name;
      const guint8 *lut;
    } color_maps[] = {
      {
          "Low contrast",
          lut_lowcontrast,
      },
      {
        "Rainbow ",
        lut_rainbow,
      },
      {
        "Red temperature",
        lut_red_temperature,
      },
      {
        "Blue Green Red Yellow",
        lut_blue_green_red_yellow
      },
      {
        "Blue White",
        lut_blue_white
      },
      {
        "Green Red Blue White",
        lut_grn_red_blu_wht
      }
    };
    // This is a temporary solution to the fact that img_org is changed
    // to a GivImage. Generate a pixbuf image from it and use it for the
    // "old" code. A more generic solution should be written.
    double min = selfp->contrast_min;
    double max = selfp->contrast_max;

    GdkPixbuf *org_pixbuf = giv_image_get_pixbuf(selfp->img_org,
                                                 selfp->current_slice,
                                                 min, max);
    if (!org_pixbuf) {
        app_error(self,
                  "Failed allocating a color image of size %dx%d pixels",
                  selfp->img_org->width,
                  selfp->img_org->height);
        return;
    }
        
    const guint8 *tmap = NULL;
    if (selfp->colormap == PSEUDO_COLOR_OFF
        //        || !selfp->img_is_mono
        ) {
        selfp->img_display = org_pixbuf;
        g_object_ref(selfp->img_display);
    }
    else {
        int width = gdk_pixbuf_get_width(org_pixbuf);
        int height = gdk_pixbuf_get_height(org_pixbuf);
        int stride = gdk_pixbuf_get_rowstride(org_pixbuf);
        int n_channels = gdk_pixbuf_get_n_channels(org_pixbuf);
        guint8 *buf = gdk_pixbuf_get_pixels(org_pixbuf);

        selfp->img_display = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
                                            FALSE,
                                            8,
                                            width, height);
        gdk_pixbuf_fill(selfp->img_display,
                        0x000000ff);

        int dstride = gdk_pixbuf_get_rowstride(selfp->img_display);
        int dn_channels = gdk_pixbuf_get_n_channels(selfp->img_display);
        guint8 *dbuf = gdk_pixbuf_get_pixels(selfp->img_display);

        guint8 dyn_map[256*3];
        if (selfp->colormap == PSEUDO_COLOR_INVERT) {
            for (int i=0; i<256; i++)
                dyn_map[3*i]=dyn_map[3*i+1]=dyn_map[3*i+2] = 255-i;
            tmap = dyn_map;
        }
        else if (selfp->colormap == PSEUDO_COLOR_EQUALIZE) {
            gint hist[3][256];
            
            memset(hist, 0, sizeof(hist));

            for (int row_idx=0; row_idx<height; row_idx++) {
                guint8 *p = buf + stride*row_idx;
                for (int col_idx=0; col_idx<width; col_idx++) {
                    for (int rgb_idx=0; rgb_idx<3;rgb_idx++) {
                        hist[rgb_idx][*p]++;
                        p++;
                    }
                }
            }
            
            for (int col_idx=0; col_idx<3; col_idx++) {
                int accsum = 0;
                for (int hist_idx=0; hist_idx<256; hist_idx++) {
                    dyn_map[hist_idx*3+col_idx] = (accsum * 255) / (width * height);
                    accsum+= hist[col_idx][hist_idx];
                }
            }
            tmap = dyn_map;
        }
        else if (selfp->colormap == PSEUDO_COLOR_NORMALIZE) {
            guint8 min[3], max[3];
            
            min[0] = min[1]=min[2] = 255;
            max[0] = max[1] = max[2] = 0;

            for (int row_idx=0; row_idx<height; row_idx++) {
                guint8 *p = buf + stride*row_idx;
                for (int col_idx=0; col_idx<width; col_idx++) {
                    for (int rgb_idx=0; rgb_idx<3; rgb_idx++) {
                        if (*p < min[rgb_idx]) 
                            min[rgb_idx] = *p;
                        if (*p > max[rgb_idx])
                            max[rgb_idx] = *p;
                        p++;
                    }
                }
            }

            for (int col_idx=0; col_idx<3; col_idx++) {
                for (int hist_idx=0; hist_idx<256; hist_idx++) {
                    int max_min = (max[col_idx] - min[col_idx]);
                    if (max_min==0)
                        max_min = 1;
                    int map_value = 255 * (hist_idx-min[col_idx])
                        / max_min;
                    if (map_value > 255)
                        map_value = 255;
                    else if (map_value < 0)
                        map_value = 0;
                    dyn_map[hist_idx*3+col_idx] = map_value;
                }
            }
            tmap = dyn_map;
        }
        else 
            tmap = color_maps[selfp->colormap-PSEUDO_COLOR_LOW_CONTRAST].lut;
        
        for (int row_idx=0; row_idx<height; row_idx++) {
            for (int col_idx=0; col_idx<width; col_idx++) {
                int idx = row_idx * stride + col_idx * n_channels;
                int didx = row_idx * dstride + col_idx * dn_channels;
                dbuf[didx+0] = tmap[buf[idx]*3];
                dbuf[didx+1] = tmap[buf[idx+1]*3+1];
                dbuf[didx+2] = tmap[buf[idx+2]*3+2];
            }
        }
    }
#if 0
    gtk_image_viewer_set_image(GTK_IMAGE_VIEWER(selfp->w_imgv),
                               selfp->img_display);
#endif
    g_object_unref(org_pixbuf);

    // Notify the colorbar
    giv_color_map_set_rgb_colormap(GIV_COLOR_MAP(selfp->w_color_map_bar),
                                   (guint8*)tmap, 256*3);
}

static void cb_image_reference(GtkWidget *widget,
                               const char *filename,
                               gpointer user_data)
{
    GivWin *self = (GivWin *)user_data;
    slip fn_path(filename);

#if 0
    app_error(self, "cb_image_reference = %s",
              filename);
#endif
    
    if (!g_file_test(fn_path, GFileTest(G_FILE_TEST_IS_REGULAR))) {
        GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                           selfp->filename_list_index);
        gchar *fn0 = (gchar*)g_ptr_array_index(fn_list, 0);
        gchar *dirname = g_path_get_dirname(fn0);
        fn_path = slip(dirname) + "/" + filename;
        g_free(dirname);

        if (!g_file_test(fn_path, GFileTest(G_FILE_TEST_IS_REGULAR))) {
            app_error(self,
                      "Failed loading file %s!\n", filename);
            return;
        }
    }

    
#if 0
    giv_win_load_file(GIV_WIN(user_data), fn_path);
#endif
    g_ptr_array_add(selfp->cb_names, g_strdup(fn_path));

    // Update the info being displayed
#if 0
    giv_win_set_image_info(self);
#endif

}

#if 0
static void cb_set_orientation(giv_parser_orientation_t hflip,
                               giv_parser_orientation_t vflip,
                               gpointer user_data)
{
    GivWin *self = (GivWin *)user_data;

    if (vflip != GIV_PARSER_ORIENTATION_UNDEF) {
        cb_flip_changed(GTK_IMAGE_VIEWER(selfp->w_imgv),
                        selfp->do_flip_horizontal,
                        vflip == GIV_PARSER_ORIENTATION_FLIP,
                        self);
    }
    if (hflip != GIV_PARSER_ORIENTATION_UNDEF) {
        cb_flip_changed(GTK_IMAGE_VIEWER(selfp->w_imgv),
                        vflip == GIV_PARSER_ORIENTATION_FLIP,
                        selfp->do_flip_vertical,
                        self);
    }
}       
#endif

static void
cb_file_list_drag_data_received (GtkWidget          *widget,
				 GdkDragContext     *context,
				 gint                x,
				 gint                y,
				 GtkSelectionData   *selection_data,
				 guint               info,
				 guint               drag_time,
				 gpointer            data)
{
    GivWin *self = GIV_WIN(data);
    switch (info) {
    case DND_TEXT_URI_LIST: {
        gchar **uris;
        guint i;
        
        uris = gtk_selection_data_get_uris (selection_data);
        
        // The following works on windows... Should instead recreate
        // uris and then use common loading code...
        if (uris == NULL) {
            uris = g_new0(gchar*, 2);
            char *sdata = g_strdup((gchar*)gtk_selection_data_get_data(selection_data));
            char *nl_pos;
            if ((nl_pos = g_strstr_len(sdata, strlen(sdata), "\r")))
                *nl_pos = 0;
            if ((nl_pos = g_strstr_len(sdata, strlen(sdata), "\n")))
                *nl_pos = 0;
            
            uris[0] = sdata;
            uris[1] = 0;
        }

        // The following is a copy and paste of what is done with loading
        // from the command line and should be fixed.
        for (i = 0; uris[i] != NULL; i++) {
            gchar *path = g_filename_from_uri(uris[i], NULL, NULL);

            giv_win_read_dir_into_filename_list(self, path);

            selfp->filename_list_index = -1;
            gchar *basename = g_path_get_basename(path);
            for (int i=0; i<(int)selfp->filename_list->len; i++) {
                GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                                   i);
                gchar *fn0 = (gchar*)g_ptr_array_index(fn_list, 0);
                if (g_str_has_suffix(fn0, basename)) {
                    selfp->filename_list_index = i;
                    break;
                }
            }
            g_free(basename);

            giv_win_set_current_file(self,
                                     selfp->filename_list_index);
            g_free(path);
            
            break;
        }
        
        g_strfreev (uris);
        break;
    }
    case DND_TEXT_PLAIN:
        {
#if 0
            guchar *text = gtk_selection_data_get_text (selection_data);
#endif
            break;
        }
        
    default:
        break;
    }
    
  gtk_drag_finish (context, TRUE, FALSE, drag_time);
}

//======================================================================
//  Make the window exactly fit the marks.
//----------------------------------------------------------------------
static void
fit_marks_in_window(GivWin *self)
{
    double min_x, min_y, max_x, max_y;
    GivParser *parser = giv_widget_get_giv_parser(GIV_WIDGET(selfp->w_imgv));
    gboolean do_vlock = gtk_image_viewer_get_vlock(GTK_IMAGE_VIEWER(selfp->w_imgv));

    // Block recursive size-alloc events
    g_signal_handlers_block_by_func(selfp->w_imgv, (gpointer)&cb_image_size_alloc, self);

    
    giv_parser_get_data_bbox(parser,
                             // output
                             &min_x, &min_y,
                             &max_x, &max_y);
#if 0
    printf("min_x min_y max_x max_y = %f %f %f %f\n",
           min_x, min_y, max_x, max_y);
#endif
    double margin = selfp->margin;
    
#if 0
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(selfp->w_scrolled_win),
                                   GTK_POLICY_NEVER,
                                   GTK_POLICY_NEVER);
#endif

    if (selfp->img_org) {
        int img_w = giv_image_get_width(selfp->img_org);
        int img_h = giv_image_get_height(selfp->img_org);

        min_x = min_y = 0;
        max_x = img_w;
        max_y = img_h;
        margin = 0;
    }
    else {
        margin= 10;
        int cnv_width = gtk_widget_get_allocated_width(selfp->w_imgv);
        int cnv_height = gtk_widget_get_allocated_height(selfp->w_imgv);
        double aspect_ratio = 1.0*cnv_height/cnv_width;

        // The following is a hack around the problem of too thin
        // data in x or y... It should be solved in the gtk_image_viewer.
        if (!do_vlock) {
            if (max_x - min_x < max_y-min_y) {
                double avg_x = 0.5*(max_x+min_x);
                min_x = avg_x - 0.5/aspect_ratio*(max_y-min_y);
                max_x = avg_x + 0.5/aspect_ratio*(max_y-min_y);
            }
            if (max_y - min_y < max_x-min_x) {
                double avg_y = 0.5*(max_y+min_y);
                min_y = avg_y - aspect_ratio*0.5*(max_x-min_x);
                max_y = avg_y + aspect_ratio*0.5*(max_x-min_x);
            }
        }

        gtk_image_viewer_set_scroll_region(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                           min_x, min_y,
                                           max_x, max_y);
        // Let the user decide!
        gtk_image_viewer_set_zoom_range(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                        -1,-1);
        
        //    printf("scale c_world_center = %f %f %f\n", x_scale, c_world_center_x, c_world_center_y);
    }
    
#if 0
    printf("min_x min_y max_x max_y margin = %f %f %f %f %f\n",
           min_x, min_y, max_x, max_y,1.0*margin);
#endif

    gtk_image_viewer_zoom_to_box(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                 min_x,
                                 min_y,
                                 max_x,
                                 max_y,
                                 margin,
                                 !do_vlock);

    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(selfp->w_scrolled_win),
                                   GTK_POLICY_AUTOMATIC,
                                   GTK_POLICY_AUTOMATIC);
    // Get rid of block
    g_signal_handlers_unblock_by_func(selfp->w_imgv, (gpointer)&cb_image_size_alloc, self);
}

static double sqr(double x) {
    return x*x;
}

#if 0
/** 
 * Draw the line used for measuring. Done by cairo.
 * 
 * @param backstore 
 * @param image_viewer 
 * @param x0 
 * @param y0 
 * @param x1 
 * @param y1 
 */
static void
draw_measure_line(giv_backstore_t *back_store,
                  GtkWidget *image_viewer,
                  double x0, double y0,
                  double x1, double y1)
{
  double cx0, cy0, cx1, cy1;
  double lw = 5;
  double arrow_a = 10;
  double arrow_b = 10;
  double arrow_c = 15;
  double d; // Line distance from arrow to arrow
  cairo_t *cr = back_store->cairo;


#if 0
  // Under construction
  if (img_display)
    y_flip_max = gdk_pixbuf_get_height(img_display);
  else
    y_flip_max = global_mark_max_y + global_mark_min_y;

  if (load_transformation == TRANSFORM_VFLIP)
    {
      y1 = measure_y1;
      y2 = measure_y2;
    }
  else
    {
      y1 = y_flip_max - measure_y1;
      y2 = y_flip_max - measure_y2;
    }
#endif
    
  gtk_image_viewer_img_coord_to_canv_coord(GTK_IMAGE_VIEWER(image_viewer),
                                           x0, y0,
                                           &cx0, &cy0);
  gtk_image_viewer_img_coord_to_canv_coord(GTK_IMAGE_VIEWER(image_viewer),
                                           x1, y1,
                                           &cx1, &cy1);

  giv_backstore_restore_background (back_store);
  giv_backstore_store_background_line (back_store,
                                       (int)cx0,(int)cy0,
                                       (int)cx1,(int)cy1);
  cairo_save(cr);
  // Set up cairo so that we can draw in x-axis only.
  cairo_translate(cr, 0.5*(cx0+cx1), 0.5*(cy0+cy1));
  cairo_rotate(cr, atan2(cy1-cy0,cx1-cx0));

  d = sqrt((cx1-cx0)*(cx1-cx0)+(cy1-cy0)*(cy1-cy0));

  // Draw an arrow from (-d/2,0) to (d/2,0) based on the
  // parameters arrow_a, arrow_b, and arrow_c.
  cairo_move_to(cr, -(d/2-arrow_a), lw/2);
  cairo_line_to(cr, -(d/2-arrow_c), arrow_b);
  cairo_line_to(cr, -d/2, 0);
  cairo_line_to(cr, -(d/2-arrow_c), -arrow_b);
  cairo_line_to(cr, -(d/2-arrow_a), -lw/2);
  
  cairo_line_to(cr, (d/2-arrow_a), -lw/2);
  cairo_line_to(cr, (d/2-arrow_c), -arrow_b);
  cairo_line_to(cr, d/2, 0);
  cairo_line_to(cr, (d/2-arrow_c), arrow_b);
  cairo_line_to(cr, (d/2-arrow_a), lw/2);
  
  cairo_close_path(cr);
  cairo_fill(cr);
  cairo_restore(cr);
}

static giv_backstore_t *
create_backstore(GtkWidget *image_viewer)
{
  giv_backstore_t *back_store = new_giv_backstore (GTK_WIDGET (image_viewer) );
  giv_backstore_set_color(back_store,
                          "magenta",
                          0.95);
  giv_backstore_set_line_width(back_store, 4);
  giv_backstore_set_line_cap_extra_store(back_store, 40);
  return back_store;
}
#endif

/** 
 * Reorder the data in a pixbuf to the order needed for a a cairo
 * surface.
 * 
 * @param img 
 * @param cairo_img 
 * 
 * @return 
 */
static void pixbuf_to_cairo(GdkPixbuf *img,
                            // output
                            GdkPixbuf **cairo_img)
{
    int width = gdk_pixbuf_get_width(img);
    int height = gdk_pixbuf_get_height(img);
    int stride = gdk_pixbuf_get_rowstride(img);
    guint8 *buf = gdk_pixbuf_get_pixels(img);
    bool has_alpha = gdk_pixbuf_get_has_alpha(img);
    
    *cairo_img = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
                                TRUE,
                                8,
                                width, height);
    guint8 *cbuf = gdk_pixbuf_get_pixels(*cairo_img);
    int cstride = gdk_pixbuf_get_rowstride(*cairo_img);
        
    for (int row_idx = 0; row_idx < height; row_idx++) {
	guchar *p = buf  + row_idx * stride;
	guchar *pd = cbuf + row_idx * cstride;

	for (int col_idx = 0; col_idx < width; col_idx ++) {
            guchar r = *p++;
            guchar g = *p++;
            guchar b = *p++;
            guchar a=255;
            if (has_alpha)
                p++;
            
            *pd++ = b;
            *pd++ = g;
            *pd++ = r;
            *pd++ = a;
	}
    }
}

static gchar *read_pnm_comment(const char *filename)
{
    FILE *fh;
    char str[100];
    slip comment;

    if ((fh = fopen(filename, "rb")) == NULL)
        return 0;
    
    fgets((char*)str, sizeof(str),fh);

    if (!((str[0]=='P') && (str[1]>='1' && str[1]<= '6'))) {
        return NULL;
    }
    
    while(1) {
        int str_start = 1;
        int len;
        
	fgets(str, sizeof(str), fh);

        if (str[0] == '#') {
            if (str[str_start] == ' ')
                str_start++;                   /* Skip "# " in the begging of comments */
            str[sizeof(str)-1]=0;
            len = strlen(str);
            comment += str+str_start;

            while ((len == (int)strlen(str)-1) && (str[len-1]!='\n')) { 
                fgets(str,sizeof(str),fh);
                len = strlen(str);
                comment += str;
            }
        }
        else 
            break;
    }

    return g_strdup(comment);
}

bool is_file_ext(const char *filename,
                 const char *ext_match)
{
    gchar *pattern = g_strdup_printf("\\.(%s)$",
                                     ext_match);
    bool res = g_regex_match_simple(pattern,
                                    filename,
                                    G_REGEX_CASELESS,
                                    GRegexMatchFlags(0));
    g_free(pattern);
    return res;
}

static gboolean
cb_load_image_when_idle(gpointer user_data)
{
    GivWin *self = (GivWin *)user_data;
    giv_win_set_current_file(self, selfp->idle_index);
    selfp->idle_handle = -1;

    return false;
}

static gboolean
cb_redraw_when_idle(gpointer user_data)
{
    GivWin *self = (GivWin *)user_data;
    giv_win_redraw(self);
    return false;
}

static void
draw_caliper(GivWin *self,
             cairo_t *cr,
             DovtkLassoContext lasso_context,
             double x0, double y0,
             double x1, double y1,
             int measure_type,
             const char *caliper_text)
{
  int margin = 0;
  if (lasso_context != DOVTK_LASSO_CONTEXT_PAINT)
    {
      margin = 5;
      cairo_set_line_width (cr, margin);
    }
  else
    cairo_set_line_width (cr, 3);

  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);

  if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT)
    cairo_set_source_rgba(cr, 10*0x4d/255.0,1.0*0xaa/255.0,0,0.5);
  else if (lasso_context == DOVTK_LASSO_CONTEXT_LABEL)
    dovtk_lasso_set_color_label(selfp->lasso, cr, 1);

  // Make a gradient for horizontal and vertical measurements
  cairo_pattern_t *pat = NULL;
  cairo_matrix_t matrix;
  if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT)
    {
      pat = cairo_pattern_create_linear (0.0, 0,
                                         0.0, 20);
      cairo_pattern_add_color_stop_rgba   (pat,
                                           0,
                                           0x50/255.0,
                                           0x2d/255.0,
                                           0x16/255.0,
                                           0.95);
      cairo_pattern_add_color_stop_rgba   (pat,
                                           2.0/20,
                                           10*0x4d/255.0,1.0*0xaa/255.0,0,0.5);
      cairo_pattern_add_color_stop_rgba   (pat,
                                           1.0,
                                           10*0x4d/255.0,1.0*0xaa/255.0,0,0.0);
    }

  if (measure_type == MEASURE_TYPE_VERTICAL)
    {
      int w = gtk_widget_get_allocated_width(selfp->w_scrolled_win);
      if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT)
        {
          cairo_matrix_init_translate(&matrix, 0, y0);
          cairo_matrix_scale(&matrix,1.0,-1.0);
          cairo_pattern_set_matrix(pat, &matrix);
          cairo_set_source (cr, pat);
        }
      else if (lasso_context == DOVTK_LASSO_CONTEXT_LABEL)
        dovtk_lasso_set_color_label(selfp->lasso, cr, 2);
  
      cairo_rectangle(cr, 0, y0-20, w, 20);
      cairo_fill (cr);
  
      if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT)
        {
          cairo_matrix_init_translate(&matrix, 0, -y1);
          cairo_pattern_set_matrix(pat, &matrix);
          cairo_set_source (cr, pat);
        }
      else if (lasso_context == DOVTK_LASSO_CONTEXT_LABEL)
        dovtk_lasso_set_color_label(selfp->lasso, cr, 3);
      cairo_rectangle(cr, 0, y1, w, 20);
      cairo_fill(cr);
  }
  else if (measure_type == MEASURE_TYPE_HORIZONTAL)
    {
      int h = gtk_widget_get_allocated_width(selfp->w_scrolled_win);
      if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT)
        {
          cairo_matrix_init_rotate(&matrix, MY_PI/2);
          cairo_matrix_translate(&matrix, x0, 0);
          cairo_matrix_scale(&matrix,-1.0,1.0);
          cairo_pattern_set_matrix(pat, &matrix);
          cairo_set_source (cr, pat);
        }
      else if (lasso_context == DOVTK_LASSO_CONTEXT_LABEL)
        dovtk_lasso_set_color_label(selfp->lasso, cr, 2);
  
      cairo_rectangle(cr, x0-20, 0, 20, h);
      cairo_fill (cr);
  
      if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT)
        {
          cairo_matrix_init_rotate(&matrix, MY_PI/2);
          cairo_matrix_translate(&matrix, -x1, 0);
          cairo_pattern_set_matrix(pat, &matrix);
          cairo_set_source (cr, pat);
        }
      else if (lasso_context == DOVTK_LASSO_CONTEXT_LABEL)
        dovtk_lasso_set_color_label(selfp->lasso, cr, 3);
      cairo_rectangle(cr, x1, 0, 20,h);
      cairo_fill(cr);
    }
  else
    {
      cairo_translate(cr,
                      0.5 * (x0+x1),
                      0.5 * (y0+y1));
  
      double angle = atan2(y1-y0,x1-x0);
      cairo_rotate(cr, angle);
      double dist = sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
  
      cairo_rectangle(cr, -dist/2-margin, -20-margin,
                      dist+2*margin, 20+2*margin);
      cairo_fill(cr);
  
      if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT)
        cairo_set_source_rgb(cr, 0x50/255.0,0x2d/255.0,0x16/255.0);
      else if (lasso_context == DOVTK_LASSO_CONTEXT_LABEL)
        dovtk_lasso_set_color_label(selfp->lasso, cr, 2);
  
      double calip_height = 50;
      cairo_move_to(cr, -dist/2+margin,calip_height/2+margin); 
      double dy = -(calip_height+3*margin)/3;
      cairo_rel_curve_to(cr,
                         -15-2*margin,dy,
                         -15-2*margin,2.5*dy,
                         -15-2*margin,3*dy);
      cairo_line_to(cr, -dist/2+margin,-calip_height/2-margin); 
                    
      cairo_close_path(cr);
          
      if (lasso_context == DOVTK_LASSO_CONTEXT_LABEL) {
        cairo_fill_preserve(cr);
        cairo_set_line_width(cr, 5);
        cairo_stroke(cr);
        dovtk_lasso_set_color_label(selfp->lasso, cr, 3);
      }
  
      cairo_move_to(cr, dist/2-margin,calip_height/2+margin); 
      cairo_rel_curve_to(cr,
                         15+2*margin,dy,
                         15+2*margin,2.5*dy,
                         15+2*margin,3*dy);
      cairo_line_to(cr, dist/2-margin,-calip_height/2-margin); 
                    
      cairo_close_path(cr);
  
      if (lasso_context == DOVTK_LASSO_CONTEXT_PAINT) 
        cairo_fill(cr);
      else {
        cairo_set_line_width(cr, 5);
        cairo_fill_preserve(cr);
        cairo_stroke(cr);
      }

      // No need to draw text for label context. Though I'm doing it
      // because I'm not sure of text height calculations on windows!
      if (1||lasso_context != DOVTK_LASSO_CONTEXT_LABEL) {
#ifdef _WIN32
        // TBD - Figure out how to get a font that matches the caliper height!
        PangoFontDescription *font_descr = pango_font_description_from_string("Segoe UI 10");
#else
        PangoFontDescription *font_descr = pango_font_description_from_string("Sans 15");
#endif
        PangoContext *context = pango_cairo_create_context(cr);
        cairo_font_options_t *options =  cairo_font_options_create();
        cairo_font_options_set_hint_style(options,CAIRO_HINT_STYLE_NONE);
        pango_cairo_context_set_font_options(context, options);
        PangoLayout *pango_layout = pango_layout_new(context);
    
        pango_layout_set_font_description(pango_layout, font_descr);
        pango_layout_set_text(pango_layout, caliper_text, -1);
        int layout_width, layout_height;
        pango_layout_get_size(pango_layout, &layout_width, &layout_height);
    
        cairo_move_to(cr, -0.5*layout_width/PANGO_SCALE,-0.9*layout_height/PANGO_SCALE);
        if (lasso_context==DOVTK_LASSO_CONTEXT_PAINT)
          cairo_set_source_rgba(cr, 0,0,0,1); // 0x50/255.0,0x2d/255.0,0x16/255.0,1);
    
        pango_cairo_show_layout(cr, pango_layout);
        g_object_unref(pango_layout);
        pango_font_description_free(font_descr);
        g_object_unref(context);
        cairo_font_options_destroy(options);
      }
    }

  if (pat)
    cairo_pattern_destroy (pat);
}

/** 
 * Draw  whatever overlay you want on the image. If the do_mask
 * is on, then you should paint in black and with a pen that
 * is thicker than the drawing. 
 */
static void
my_lasso_draw(cairo_t *cr,
              DovtkLassoContext context,
              gpointer user_data)
{
    GivWin *self = GIV_WIN(user_data);
    double start_x, start_y;
    double end_x, end_y;

    gtk_image_viewer_img_coord_to_canv_coord(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                             selfp->measure_x1,
                                             selfp->measure_y1,
                                             &start_x, &start_y);
    gtk_image_viewer_img_coord_to_canv_coord(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                             selfp->measure_x2,
                                             selfp->measure_y2,
                                             &end_x, &end_y);

    slip caliper_text;
    double dist = sqrt(sqr(selfp->measure_x2 - selfp->measure_x1)
                       +sqr(selfp->measure_y2 - selfp->measure_y1));
    caliper_text = slipprintf("%.1f%s",
                              dist*selfp->pixelsize,
                              selfp->pixelsize_unit);
    draw_caliper(self,
                 cr,
                 context,
                 start_x, start_y,
                 end_x, end_y,
                 selfp->measure_type,
                 caliper_text);

#if 0
    cairo_stroke(cr);
#endif
}

/** 
 * Draw  whatever overlay you want on the image. If the do_mask
 * is on, then you should paint in black and with a pen that
 * is thicker than the drawing. 
 */
static void
my_lasso_draw_rectangle(cairo_t *cr,
                        DovtkLassoContext context,
                        gpointer user_data)
{
    GivWin *self = GIV_WIN(user_data);
    double start_x, start_y;
    double end_x, end_y;

    gtk_image_viewer_img_coord_to_canv_coord(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                             selfp->measure_x1,
                                             selfp->measure_y1,
                                             &start_x, &start_y);
    gtk_image_viewer_img_coord_to_canv_coord(GTK_IMAGE_VIEWER(selfp->w_imgv),
                                             selfp->measure_x2,
                                             selfp->measure_y2,
                                             &end_x, &end_y);

    // Draw a rectangle
    double min_x = start_x;
    if (end_x < min_x)
        min_x = end_x;
    double min_y = start_y;
    if (end_y < min_y)
        min_y = end_y;

    cairo_rectangle(cr, min_x, min_y,
                    fabs(end_x-start_x), fabs(end_y-start_y));

    if (context == DOVTK_LASSO_CONTEXT_PAINT)
        cairo_set_source_rgba(cr, 1,0,0,0.6);
    else {
        cairo_set_source_rgba(cr, 1,1,1,1);
        cairo_set_line_width(cr, 5);
    }
        
    if (context == DOVTK_LASSO_CONTEXT_LABEL) 
        dovtk_lasso_set_color_label(selfp->lasso, cr, 1);

    cairo_stroke(cr);
}

static int cmd_ping(GLibJsonRpcServer *server,
                    const char *method,
                    JsonNode *params,
                    JsonNode **response,
                    gpointer user_data)
{
  printf("pong!\n");

  *response = json_node_new(JSON_NODE_VALUE);
  json_node_set_string(*response, "pong");
  
  return 0;
}

static int cmd_help(GLibJsonRpcServer *server,
                    const char *method,
                    JsonNode *params,
                    JsonNode **response,
                    gpointer user_data)
{
  *response = json_node_new(JSON_NODE_VALUE);
  json_node_set_string(*response,
                       "The following remote commands are supported\n"
                       "\n"
                       "  * ping - Check that giv is alive\n"
                       "  * load_file fn - Load an image or a giv file\n"
                       "  * giv_string s - Replace the giv file\n"
                       "  * pick_coordinate - Returns the next xy coordinate clicked bythe user\n"
                       );
  
  return 0;
}

static int cmd_load_file(GLibJsonRpcServer *server,
                         const char *method,
                         JsonNode *params,
                         JsonNode **response,
                         gpointer user_data)
{
  GivWin *self = (GivWin*)user_data;
  *response = json_node_new(JSON_NODE_VALUE);
  JsonReader *reader = json_reader_new(params);
  
  // Assume array at the moment
  json_reader_read_element(reader, 0);
  const char *filename = json_reader_get_string_value(reader);
  if (filename == NULL) {
      json_node_set_string(*response, "No filename given");
      return 0;
  }

  // The following ugly code is the same as is used in the
  // open response callback. It should be joined!
  char *basename = g_path_get_basename(filename);
  giv_win_read_dir_into_filename_list(self, filename);
  selfp->filename_list_index = -1;
  for (int i=0; i<(int)selfp->filename_list->len; i++)
    {
      GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                         i);
      if (g_str_has_suffix((const gchar*)g_ptr_array_index(fn_list, 0),
                           basename)) {
        selfp->filename_list_index = i;
        break;
      }
    }
  g_free(basename);
  if (selfp->filename_list->len
      && selfp->filename_list_index < 0) {
    GPtrArray *fn_list = (GPtrArray*)g_ptr_array_index(selfp->filename_list,
                                                       0);
    
    giv_win_load_file(self, (gchar*)g_ptr_array_index(fn_list, 0));
    selfp->idle_index = 0;
    selfp->idle_handle = g_idle_add(cb_load_image_when_idle,
                                    self);
  }
  else
  {
    selfp->idle_index = selfp->filename_list_index;
    selfp->idle_handle = g_idle_add(cb_load_image_when_idle,
                                    self);
  }

  if (last_image_path)
    g_free(last_image_path);
  last_image_path = strdup(filename);

  g_object_unref(reader);
  json_node_set_string(*response, "Ok");
  
  return 0;
}

static int cmd_giv_string(GLibJsonRpcServer *server,
                          const char *method,
                          JsonNode *params,
                          JsonNode **response,
                          gpointer user_data)
{
  GivWin *self = (GivWin*)user_data;
  *response = json_node_new(JSON_NODE_VALUE);
  JsonReader *reader = json_reader_new(params);
  bool do_append = false;

  int nelem = json_reader_count_elements(reader);
  if (nelem<1)
    {
      json_node_set_string(*response, "Error! Not enough parameters");
      return -1;
    }

  int i;
  const char *S_;

  // Parse arguments that start with -
  for (i=0; i<nelem; i++)
    {
      json_reader_read_element(reader, 0);
      S_ = json_reader_get_string_value(reader);
      json_reader_end_element (reader);

      if (S_[0]!='-')
        break;
      
      // Parse the argument
      CASE("-append")
        {
          do_append=true;
          continue;
        }
      // Ignore unknown parameters
    }
  
  const char *giv_string = S_;

  // Erase the old giv string
  // TBD, make this configurable?
  if (!do_append)
      giv_widget_clear_giv(GIV_WIDGET(selfp->w_imgv));
  giv_widget_add_giv_from_string(GIV_WIDGET(selfp->w_imgv), giv_string);

  g_object_unref(reader);
  json_node_set_string(*response, "Ok");
  g_idle_add(cb_redraw_when_idle, self);
  
  return 0;
}

static gboolean cb_idle_set_cursor(gpointer user_data)
{
  GivWin *self = (GivWin*)user_data;
  gdk_window_set_cursor(gtk_widget_get_window(selfp->w_imgv),
                        selfp->current_cursor);
  return false;
}

static int cmd_pick_coordinate(GLibJsonRpcServer *server,
                               GLibJsonRpcAsyncQuery *query,
                               const char *method,
                               JsonNode *params,
                               gpointer user_data)
{
  GivWin *self = (GivWin*)user_data;
  selfp->do_pick_coordinate = true;
  selfp->json_query = query;
  selfp->current_cursor = selfp->cursor_plus;
  g_idle_add(cb_idle_set_cursor, self);
  
  return 0;
}

static void giv_win_json_pick_reply(GivWin *self, const gchar *error, double x, double y)
{
  selfp->do_pick_coordinate = false;

  // Build a json array with the reply
  if (error==NULL)
    {
      JsonBuilder *builder = json_builder_new ();
      json_builder_begin_array (builder);
      json_builder_add_double_value(builder,x);
      json_builder_add_double_value(builder,y);
      json_builder_end_array (builder);
      JsonNode *response = json_node_copy(json_builder_get_root (builder));
      g_object_unref(builder);
      
      glib_jsonrpc_server_send_async_response(selfp->json_query,
                                              0,
                                              response);
    }
  else
    {
      JsonNode *error_response = glib_jsonrpc_json_new_string_node(error);
      glib_jsonrpc_server_send_async_response(selfp->json_query,
                                              -1,
                                              error_response);
    }
  
  gdk_window_set_cursor(gtk_widget_get_window(selfp->w_imgv), NULL);
  selfp->current_cursor = NULL;
}

// Define remote commands
static void create_remote_commands(GivWin *self)
{
  glib_jsonrpc_server_register_command(selfp->jsonrpc_server,
                                       "ping",
                                       cmd_ping,
                                       self);
  glib_jsonrpc_server_register_command(selfp->jsonrpc_server,
                                       "load_file",
                                       cmd_load_file,
                                       self);
  glib_jsonrpc_server_register_command(selfp->jsonrpc_server,
                                       "giv_string",
                                       cmd_giv_string,
                                       self);
  glib_jsonrpc_server_register_async_command(selfp->jsonrpc_server,
                                             "pick_coordinate",
                                             cmd_pick_coordinate,
                                             self);
  glib_jsonrpc_server_register_command(selfp->jsonrpc_server,
                                       "help",
                                       cmd_help,
                                       self);
}

%}
